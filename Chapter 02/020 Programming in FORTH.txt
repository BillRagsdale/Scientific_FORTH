&mmmm waLMwmmmmm

Programming in FORTH

Comm!

§1 The structure of FORTH
§2 Extending the dictionary

§3 Stacks and reverse Polish notation (RPN)
§§1 Manipulating the parameter stack

552 The return stack and its uses

54 Fetching and storing
§5 Arithmetic operations
§6 Comparing and testing
§7 Looping and structured programming
58 The pearl of FORTH
§§1 Dummy words
552 Deﬁning ”deﬁning" words
§§3 Run-time vs. compile-time actions
§§4 Advanced methods of controlling the compiler
§9 Strings
§10 FORTH programming style
§§1 Structure
§§2 “Top-down” design
§§3 information hiding
§§4 Documenting and commenting FORTH code
§§5 Safety

NNNN—bddg
#5w-‘0‘IU‘Q

8888

t$8888828

11

12

Chapter 2 - Programming In FORTH Sclentlﬂc Forth

This chapter brieﬂy reviews the main ideas of FORTH to let the

reader understand the program fragments and subroutines
that comprise the meat of this book. We make no pretense to
complete coverage of standard FORTH programming methods.
Chapter 2 is not a programmer’s manual!

Suppose the reader is stimulated to try FORTH - how can he
proceed? Several excellent FORTH texts and references are
available: Starting FORTHl and Thinking FORTH2 by Leo
Brodie; and FORTH: a Text and Reference3 by M.Kelly and
N.Spies. I strongly recommend reading FTRor SF (or both)
before trying to use the ideas from this book on a FORTH system.
(Or at least read one concurrently.)

he (commercial) GEnie information network maintains a ses-
sion devoted to FORTH under the aegis of the Forth Interest
Group (FIG).

FIG publishes a journal Forth Dimensions whose object is the
exchange of programming ideas and clever tricks.

The Association for Computing Machinery (11 West 42nd St.,
New York, NY 10036) maintains a Special Interest Group on
FORTH (SIGForth).

The Institute for Applied FORTH Research (Rochester, NY)
publishes the refereed Journal of FORTH Application and Re-
search, that serves as a vehicle for more scholarly and theoretical
papers dealing with FORTH.

Finally, an attempt to codify and standardize FORTH is under-
way, so by the time this book appears the ﬁrst draft of an ANS
FORTH and extensions may exist.

 

PP!“

L. Brodie, Starring FORTH, 2nd ed. (Prentice-Hall, NJ, 1986), referred to hereafter as SF.
L. Brodie, Thinking FORTH (Prentice-Hall, NJ 1984), referred to hereafter as Tl".
M. Kelly and N. Spies, FOR TH: a Tea and Reference (Prentice-Hall, NJ , 1986), referred to

hereafter as FTR.

mm Ml-Whm 13

It TheatmctmootFORTl-t

e "atom" of FORTH is sword — a previously-deﬁned opera-
tion (deﬁned in terms of machine code or other, previously-
dcﬁned words) whose definition is stored in a series of linked lists
called the dictionary. The FORTH operating system is an endless
loop (outer interpreter) that reads the console and interprets the
input stream, consulting the dictionary as necessary. If the stream
contains a word in the dictionary the interpreter immediately
executes that word.

 

 

Yes
EN? l word? lYilexscure l

_J
No l Interpret ] l

iii—J | number? Y“ NUMBER ]

 

 

 

 

 

 

 

 

 

 

Fig. 2-1 Overview of FORTH outer interpreter

In general, because FORTH is interpretive as well as compiled,
the best way to study something new is in front of a computer
running FORTH. Therefore we explain with illustrations, expect-
ing the reader to try them out.

In what follows, anything the user types in will be set in Helvetica,
such as DECIMAL below.

Machine responses appear in ordinary type.
We now give a trivial illustration:

DECIMAL <cr> ok

 

Suewasive words in the input stream are separated from each other by blank spaces. ASCII
”at, the standard FORTH «limiter.

OJtlthNotk—Alriu'ureaerved.

Chapter 2 - Programming in FORTH Scientific Forth

Ham:

0 < or > means “the user pushes the ENTER or .- button".

0 0k is what FORTH says in response to an input line, if nothing
has gone wrong.

a DECIMAL is an instruction to use base 10 arithmetic. FORTH
will use any base on tell it, within reason, but usually only
DECIMAL and H (hexadecimal) are predeﬁned.

When the outer interpreter (see Fig. 2.1 on p. 13) encounters text
with no dictionary entry, it tries to interpret it as a NUMBER.

It places the number in a special memory location called “the top
of the stack” (T05)5

217 +. <cr> 190k

3919.5:

0 FORTH interprets 2 and 17 as numbers, and pushes them onto
the stack. “ + ” is a word and so is “.” so they are EXECUTEd.

o + adds 2 to 17 and leaves 19 on the stack.

a The word . (called “cmit”) removes 19 from the stack and
displays it on the screen.
We might also have said6
HEX 0A14*. <cr> C8 ok

(Do you understand this? Hint: HEX stands for “switch to
hexadecimal arithmetic”)

 

We will explain about the stack in §2.3.
since FORTH uses words, when we enter an input line we say the corresponding phrase.

If the incoming text can neither be located in the dictionary nor
interpreted as a number, FORTH issues an error message.

52 Extending the dictionary

The compiler is one of FORTl-I’s most endearing features. It is

elegant, simple, and mostly written in FORTH. Although the
technical details of the FORTH compiler are generally more
interesting to systems developers than to scientists, its com-
ponents can often be used to solve programming problems. When
this is the case, we necessarily discuss details of the compiler. In
this section we discuss how the compiler extends the dictionary.
In §2§§8 below we examine the parts of the compiler in greater
detail.

FORTH has special words that allow the creation of new diction-
ary entries, i.e., new words. The most important are “ : " (“start a
new deﬁnition") and “ ; ” (“end the new definition").

Consider the phrase

: NEW-WORD WORD1 17 WORDZ . . . WORDn ; ok

The initial “ : " is EXECUTEd because it is already in the diction-
ary. Upon execution, “ : " does the following:

o Creates a new dictionary entry, NEW-WORD, and switches
from interpret- to compile mode.

0 In compile mode, the interpreter looks up words and — rather
than executin them — installs ointers to their code. If the text
is a number ( 7 above), FOR builds the literal number into
the dictionary space allotted for NEW-WORD.

o The action of NEW-WORD will be to EXECUTE sequentially
the previously-defined words WORD1,WORDZ, ...WORDn,
placing any built-in numbers on the stack as they occur.

16

Chapter 2 - Programming in FORTH Scientiﬁc Forth

o The FORTH co aililerpo EXECUTEs the last word “ ; " of the
deﬁnition, by inst dc (to return control to the next outer
level of the mterpretegr ) then switching back from compile to
interpret mode. Most other languages treat tokens like “ ; " as
ﬂags (in the input stream}= that triger actions rather than
act1ons in their own right ORTH lets components execute
themselves.

In FORTH all subroutines are words that are invoked when they
are named. No explicit CALL or GOSUB statement is required.

The above deﬁnition of NEW-WORD is extremely structured
compared with FORTRAN or BASIC. Its deﬁnition is just a series
of subroutine calls.

e now illustrate how to deﬁne and use a new word using the

previously deﬁned words “ : ”and “ ; ”. Enter the phrase (this
new word a + expects 3 numbers, a, b, and c on the stack)

: * + * + ; ok
Mn:
0 at multiplies b with c, leaving b*C.
o + then adds b*c to a, leaving a + b*c behind. .
Now we actually try out a + :
DECIMAL 56 7 *+. 47 ok
N91932:
o The period . is not a typo, it EMlTs the result.
a FORTH’s response to a b c e + . is a + b‘c ok.

 

7.

This level could be either the outer interpreter or a word that invokes NEW-WORD .

scmm

Glenna-Pmmonm 17

What if we were to enter 0 + with nothing on the stack ? Let's try

it and see ( .3 is a word that displays the stack without changing
its contents):

.5 empty stack ok

‘ + empty stack ok

Suppose you entered the input line

HEXSS7t+.<cr>mok

What would you expect the response xxx to be?

53 Stacks and reverse Polish notation (RPN)

e now discuss the stack and the “reverse Polish” or “postﬁx”

arithmetic based on it. (Anyone who has used one of the
Hewlett-Packard calculators should already be familiar with the
basic concepts.)

A Polish mathematician (J .Lukasewcleia) showed that numeri-
cal calculations require an irreducible minimum of elementary
operations (fetching and storing numbers as well as addition,
subtraction, multiplication and division). The minimum is ob-
tained when the calculation is organized by “stack" arithmetic.

Thus virtually all central processors (CPU’s) intended for arith-
metic operations are designed around stacks. FORTH makes
efﬁcient use of CPU's by reflecting this underlying stack architec-
ture in its syntax, rather than translating algebraic-looking pro-
gram statements (“inﬁx” notation) into RPN-based machine
operations as FORTRAN, BASIC, C and Pascal do.

OMVNohio-Mnghtareurved.

Chapter 2 — Programming in FORTH Scientiﬁc Forth

But what is a stack? As the name implies, a stack is the machine
analog of a pile of cards with numbers written on them. Numbers
are always added to, and removed from, the top of the pile. (That
is, a stack resembles a job where layoffs follow seniority: last in,
ﬁrst out.) Thus, the FORTH input line

DECIMAL 2 5 73 -16 0k

followed by the line

+-*.yyyok

leaves the stack in the successive states shown in Table 2-1 below

 

 

 

 

Cell # Initial Ops- + _ * _
0 ~16 ‘ Result 57

2 5 ’ 2

3 2 ‘

 

 

Table 2-1 Picture of the stack during operaa'ons

We usually employ zero-based relative numbering in FORTH
data structures —stacks, arrays, tables, etc.- so TOS (“top of
stac ”) is given relative #0, NOS (“next on stack”) #1, etc.

(I H

The operation . (“emit") displays -104 to the screen, leaving
the stack empty. That is, yyy above is -104.

mm own-warm 10

Ill Whom”
FORTH system incorporate (at least) two stacks: the

parameter stack which we now discuss, and the return stack
which we defer to 92.3.2.

In order to use a stack-based system, we must be able to put
numbers on the stack, remove them, and rearrange their order.
FORTH includes standard words for this purpose.

Putting numbers on the stack is easy: one simply types the number
(or it appears in the deﬁnition of a FORTH word).

To remove a number we have the word DROP that drops the
number from TOS and moves up all the other numbers.

Tb exchange the top 2 numbers we have .

DUP duplicates the TOS into NOS, pushing down all the other
numbers.

ROT rotates the top 3 numbers.

Cell # initial OPS-r DROP SWAP HOT DUP

-16 Result 73

 

Table 2-2 Stack manipulation operators

emvNouo—Mﬂomw-

20

Chapter 2 — Programming In FORTH Scientiﬁc Forth

These actions are shown on page 19 above in Thble 2—2 (we show
what each word does to the initial stack).

In addition the words OVER, UNDER, PICK and ROLL act as
shown in Table 2-3 below (note PICK and ROLL must be

 

 

Cell # initial 0P8-' OVER UNDER 4 PICK 4 ROLL
o -16 Result 73 -16

1 73 —» -1e 73

2 5 73 ~16

3 2' g 5 . _ 5

4 V 2 ,_ 2

 

 

 

Table 2-3 More stack manipulation operators

preceded by an integer that says where on the stack an element
gets PlCKed or ROLLed).

Clearly, 1 PICK is the same as DUP, 2 PICK is a synonym for
OVER, 2 ROLL means SWAP, and 3 ROLL means ROT.

As Brodie has noted (TF), it is rarely advisable to have aword use
a stack so deep that PICK or ROLL is needed. It is generally better
to keep word deﬁnitions short, using only a small number of
arguments on the stack and consuming them to the extent pos-
sible. On the other hand, HOT and its opposite, -ROT8, are often
useful.

 

8.

deﬁned as : -ROT HOT HOT ;

Mz-PWHFORTH 21

u: Thoretumatacttanditaueaa

We have remarked above in §2§§2 that compilation establishes

links from the calling word to the previously- deﬁned word
being invoked. Part of the linkage mechanism ——during actual
execution- is the return stack (rstack): the address of the next
word to be invoked after the currently executing word is placed
on the rstack, so that when the current word is done, the system
jumps to the next word. Although it might seem logical to call the
address on the rstack the next address, it is actually called the
return address for historical reasons.

In addition to serving as a reservoir of return addresses (since
words can be nested, the return addresses need a stack to be put
on) the rstack is where the limits of a DO LOOP construct are
placedg.

The user can also store/retrieve to/from the rstack This is an

example of using a component for a purpose other than the
one it was designed for. Such use is not encouraged by every
FORTH text, needless to say, since it introduces the spice of
danger. To store to the rstack we say > R, and to retrieve we say
R > . DUP > R is a speedup of the phrase DUP > R . The words
D>R DR> , for maving double-length integers, also exist on
many systems. The word R@ copies the top of the rstack to the
TOS.

The danger is this: anything put on the rstack during a word’s
execution must be removed before the word terminates. If the
> R and the R > do not balance, then a wrong next address will
be jumped to and EXECUTEd. Since this could be the address
of data, and since it is being interpreted as machine instructions,
the results will be always unpredictable, but seldom amusing.

Why would we want to use the rstack for storage when we have

a perfectly good parameter stack to play with? Sometimes it
becomes simply impossible to read code that performs complex
gymnastics on the parameter stack, even though FORTH permits

such gymnastics.

 

9.

Wediacnasloopingin§27belom

22 Chapter 2 - Programming in FORTH Sclentlﬂc Form Aw

Consider a problem — say, drawing a line on a bit- mapped graphics
output device from (x,y) to (x’,y’) — that requires 4 arguments. We
have to turn on the appropriate pixels in the memory area repre-
senting the display, in the ranges from the origin to the end coor-
dinates of the line. Suppose we want to work with x and y ﬁrst, but
they are 3rd and 4th on the stack. So we have to ROLL or PICK to
get them to TOS where they can be worked with conveniently. We
probably need them again, so we use .

4PICK 4PICK (--xyx'y'xy)

 

Now 6 arguments are on the stack! See what I mean? A better
way stores temporarily the arguments x’ and y', leaving only 2 on
the stack. If we need to duplicate them, we can do it with an
already existing word, DDUP.

Complex stack manipulations can be avoided by deﬁning VARI—
ABLEs —narned locations— to store numbers. Since FORTH,
variables are typically global — any word can access them — their ,
use can lead to unfortunate and unexpected interactions among 5"
parts of a large program. Variables should be used sparingly.

 

While FORTH permits us to make variables local to the sub- if
routines that use themlo, for many purposes the rstack can ad-
vantageously replace local variables: i

‘l

o The rstack already exists, so it need not be deﬁned anew. i

a When the numbers placed on it are removed, the rstack
shrinks, thereby reclaiming some memory.

Suppose, in the previous example, we had put x’ and y’ on the
rstack via the phrase

>R >R DDUP.

Then we could duplicate and access x and y with no trouble.

 

10. See FTR, p. 3253 for a description of beheading - a process to make variables local to a small \
set of subroutines. Another technique is to embed variables within a data structure so they can-
not be referenccd inadvertently. Chapters 2§8§§3-2, 3§5§§2, 5§1§§2 and 11§2 offer examples. It

 

Mz-Pmmnm 23

mm: since the rstack is a critical component of the
execution mechanism, we mess with it at our peril. If we want to
use it, we must clean up when we are done, so it is in the same
state as when we found it. A word that places a number on the
rstack must get it off again — using R> or RDROP — before
exiting that word“. Similarly, since no LOOP uses the rstack
also, for each >R in such a loop (after DO) there must be a
corresponding R > or RDROP (before LOOP is reached).
Otherwise the results will be unpredictable and probably will crash
the system.

54 Fetching and storing

Ordinary (16-bit) numbers are fetched from memory to the

stack by “ @ " (“fetch"), and stored by “ I ” (“store”). The
word @ expects an address on the stack and replaces that address
by its contents using, e.g., the phrase X @ . The word “ I”
expects a number (NOS) and an address (T OS) to store it in, and
places the number in the memory location referred to by the
address, consuming both arguments in the process, as in the
phrase 32 X l

Double length (32-bit) numbers can similarly be fetched and
stored, by D@ and DI . (FORTH systems designed for the newer
32-bit machines sometimes use a 32-bit-wide stack and may not
distinguish between single- and double-length integers.)

Positive numbers smaller than 255 can be placed in single bytes
of memory using C@ and CI . This is convenient for operations
with strings of ASCII text, for example screen, ﬁle and keyboard
110.

In Chapters 3, 4, S and 7 we shall extend the lexicon of @ and l
words to include floating point and complex numbers.

 

ll. Whahandywaytoeidtfromawordbeforereachingtheﬁnal“;".See'l‘l‘.

OthnVNobIe-Alrigiuroaarved.

24 Chapter 2 - Programming In FORTH Scientiﬁc Form

§5 Arlthmetlc operations

The 1979 or 1983 standards, not to mention the forthcoming

ANSII standard, require that a conforming FORTH system
contain a certain minimum set of predefined words. These consist
of arithmetic operators + — * / MOD [MOD '/ for (usually)
16-bit signed-integer (-32767 to +32767) arithmetic, and
equivalents for unsigned (0 to 65535), double-length and mixed-
mode (16- mixed with 32-bit) arithmetic. The list will be found in
the glossary accompanying your system, as well as in SF and F111.

§6 Comparing and testlng

n addition to arithmetic, FORTH lets us compare numbers on
the stack, using relational operators > < = .These operators
work as follows: the phrase
2 3 > < cr > ok

will leave 0 (“false”) on the stack, because 2 (N05) is not greater
than 3 (T OS). Conversely, the phrase

23 < <cr> ok

will leave-1 (“true”) because 2 is less than 3. Relational operators
typically consume their arguments and leave a “ﬂag” to show what
happened1.'Ihose listed so far work with signed 16-bit1ntegers.
The operator U < tests unsigned 16-bit integers (0—65535).

FORTH offers unary relational operators 0 = 0 > and 0 < that
determine whether the TOS contains a (signed) 16-bit integer
that is 0, positive or negative. Most FORTHs offer equivalent
relational operators for use with double-length integers.

The relational words are used for branching and control. The
usual form is

:MAYBE 0> IF WORDl WORDZ
WORDn THEN ;

 

12. The original FORTH-79 used + 1 for “true”, 0 for “false"; many newer system that mostly fol-
low FORTH-79 use -1 for “true". PIS/FORTH is one such. Both POINT-[.83 and ANSII
FORTH require -1 for “true", 0 for “false".

arms-Warm 25

The word MAYBE expects a number on the stack, and executes
the words between IF and THEN if the number on the stack is
positive, but not otherwise. If the number initially on the stack
were negative or zero, MAYBE would do nothing.

An alternate form including ELSE allows two mutually exclusive
actions:

:CHOOSE 0> IF WORD1 . . . WOHDn
ELSE WORDt' . . . WORDn'
THEN ; (n - - )

If the number on the stack is positive, CHOOSE executes
WORDi WORD2 WORD, whereas if the number is negative
or 0, CHOOSE executes WORD1' WORDn' .

In either example, THEN marks the end of the branch, rather than
having its usual logical meaning”.

5? Looping and structured programming

FORTH contains words for setting up loops that can be deﬁnite
or indeﬁnite:

BEGIN )00t ﬂag UNTIL

The words represented by xxx are executed, leaving the TOS
(ﬂag) set to 0 (F) —at which point UNTIL leaves the loop — or
-1 (T) —at which point UNTIL makes the loop repeat from
BEGIN.

A variant is

BEGIN xxx ﬂag WHILE yyy REPEAT

Herc xxx is executed, WHILE tests the ﬂag and if it is 0 (F) leaves
the loop; whereas if flag is -1 (T) WHILE executes m and

 

13. ThishasledsomeFOngurustopreferthesynonymouswordENDIFascleuerthanTHEN.

emvm-Mmm.

26

ChepterZ—ProgrnmminginFORTi-i SclentIﬂcFonh

REPEAT then branches back to BEGIN. These forms can be used
to set up loops that repeat until some external event (pressing a
key at the keyboard, e.g.) sets the ﬂag to exit the loop. They can
also used to make endless loops (like the outer interpreter of
FORTH) by forcing flag to be 0 in a deﬁnition like

:ENDLESS BEGIN )00( 0 UNTIL ;

FORTH also implements indexed loops using the words DO
LOOP +LOOP /LOOP. These appear within deﬁnitions, e..g

: LOOP-EXAMPLE 100 0 DO )OOt LOOP ;

The words xxx will be executed 100 times as the lower limit, 0,
increases in unit steps to 99. To step by -2's, we use the phrase

—2 + LOOP

to replace LOOP, as in

: DOWN-BY-2's O 100 DO xxx -2 +LOOP ;

The word [LOOP 1s a variant of + LOOP for working with un-
signed limits1 and increments (to permit the loop index to go up
to 65535 1n 16-bit systems).

58 The pearl of FORTH

n unusual construct, CREATE. .DOES>, has been called
‘the pearl of FORT'H”15Th.is 15 more than poetic license.

CREATE is a component of the compiler that makes a new
dictionary entry with a given name (the next name in the input
stream) and has no other function.

DOES > assigns a speciﬁc run-time action to a newly CREATEd
word (we shall see this in §2§§8-3 below).

 

14.
15.

Signed l6-bit integers run from —32768 to + 32767, unsigted from 0 to 65535. See ”R.
Michael Ham, “Structured Programming”, Dr. Dobb’slmmal adel‘m Tools, October, 1%.

Sci-mm mz-Whm 27

"1 Dummy words
Sometimes we use CREATE to make a dummy entry that we
can later assign to some action:

CREATE DUMMY
CA' " DEFINES DUMMY

The second line translates as ‘The code address of 0 deﬁnes
DUMMY ”. Entry of the above phrase would let DUMMY perform

the job of 0 just by saying DUMMY. That is, FORTH lets us first
deﬁ1r6|e a dummy word, and then give it any other word’s mean-
ing .

Here is one use of this power: Suppose we have to deﬁne two
words that are alike except for some piece in the middle:

: *WORD WORD1 WORDZ " WORDS WORD4 ;
: *MIORD WORD1 WORDZ */ WORDS WORD4 ;

we could get away with 1 word, together with DUMMY from
above,

:a_or t/WORD
wOnm wonoz
DUMMY
wonoa WORD4 ;

by saying

CA' - DEFINES DUMMY *_or_"'/WORD
01'

CA' '/ DEFINES DUMMY ‘_or_‘/WORD.

 

16. This usage is a non-standard construct of BIS/FORTH.



Chapter 2 — Programming In FORTH Scientiﬁc Forth

This technique, a rudimentary example of vector-lug, saves
memory and saves programming time by letting us vary some-
thing in the middle of a definition after the deﬁnition has been
entered in the dictionary. However, this techniqlue must be used
with caution as it is akin to self-modifying code 7.

A similar procedure lets a subroutine call itself recursively, an
enormous help in coding certain algorithms.

§§2 Deﬂnlng "defining” words

The title of this section is neither a typo nor a stutter: CREATE
ﬁnds its most important use in extending the powerful class of

FORTH words called “deﬁning” words. The colon compiler“ : ”

is such a word, as are VARIABLE and CONSTANT.

The deﬁnition of VARIABLE is simple

:VARIABLE CREATE 2 ALLOT ;

Here is how we use it:

VARIABLE X < cr > ok
The inner workings of VARIABLE are these:

0 CREATE makes a dictionary entry with the next name in the
input stream — in this case, X .

0 Then the number 2 is placed on the stack, and the word ALLOT
increments the pointer that represents the current location in
the dictionary by 2 bytes.

 

Self-modifying machine code is considered a serious “no-no” by modern structured program-
ming standards. Although it is sometimes valuable, few modern cpu's are capable of handling it
safely. More often, because cpu's tend to use pipelining and parallelism to achieve speed, a
piece of code might be modiﬁed in memory, but — having been pre-fetched before modiﬁca-
tion— actually execute in unmodiﬁed form.

ervm-Mmm.

mz-Pwmhmu 29

o This leaves a 2- e vacancy to store the value of the variable
(that is, the next ictionary header begins 2 bytes above the end
of the one just deﬁned).

When the outer interpreter loop encounters a new VARIABLE's
name in the input stream, that name’s address is placed on the
stack. But this is also the location where the 2 bytes of storage
begins. Hence when we type in X, the TOS will contain the storage
address named X .

As noted in §2.4 above, the phrase X @ (pronounced “X fetch")
places the contents of address X on the stack, dropping the
address in the process. Conversely, to store a value in the named

location X, we use ! (“store"): thus

4X! <cr>ok
X@. <cr>4ok

Double-length variables are deﬁned via DVARIABLE, whose
deﬁnition is

2 DVARIABLE CREATE 4 ALLOT ;

FORTH has a method for deﬁning words initialized to contain

speciﬁc values: for example, we might want to deﬁne the
number 17 to be a word. CREATE and “ , ” (“comma") let us do
this as follows:

17 CREATE SEVENTEEN , <cr> ok
Now test itvia

SEVENTEEN @ . <cr> 170k

ChapterZ—ProgranwnlngInFORTH SclentlﬂcForth
Ngte: The word “ , ”(“comma”) puts TOS into the next 2 bytes
of the dictionary and increments the dictionary pointer by 2.

A word C, (“see-comma”) puts a byte-value into the next byte of
the dictionary and increments the pointer by 1 byte.

§§3 Run-ﬂme vs. compIIe-tlme actions

In the preceding example, we were able to initialize the variable

SEVENTEEN to 17 when we CREATEd it, but we still have to
fetch it to the stack via SEVENTEEN @ whenever we want it.
This is not quite what we had in mind: we would like to ﬁnd 17 in
T08 when we say SEVENTEEN. The word DOES > gives us
precisely the tool to do this.

As noted above, the function of DOES > is to specify a run-time
action for the "child” words of a deﬁning word. lConsider the
deﬁning word CONSTANT, deﬁned' In high- -level1 8FORI'H by

: CONSTANT CREATE , DOES> @ ;
and usedas
53 CONSTANT PRIME 0k

Now test it:

PRIME . <cr> 53 ok

What happened?

a CREATE (hidden in CONSTANT) made an entry (named 'i
PRIME , the first word in the input stream following CON- !

STANT). Then “ , " placed the TOS (the number 53) in the
next two bytes of the dictionary.

 

18. Of course CONSTANT is usually a machine—code primitive, for speed.

4———.._a

ma-an 31

e DOES > (inside CONSTANT) then appended the actions of
all words between it and “ ; " (the end of the deﬁnition of
CONSTANT) to the child word(s) deﬁned by CONSTANT.

e In this case, the only word between DOES > and ; was @ , so
all FORTH constants deﬁned by CONSTANT perform the
action of lacing their address on the stack (anything made by
CREA does this) and fetching the contents of this address.

“3-1 K”"90".
et us make a more complex example. Suppose we had pre-
viously deﬁned a word BOX ( n x y - - ) that draws a small
square box of n pixels to a side centered at (x, y) on the graphics
display. We could use this to indicate the instantaneous location
of a moving object -— say a Klingon space-ship in a space-war
game.

So we deﬁne a deﬁning word that creates (not very realistic
looking) space ships as squares n pixels on a side:

: SPACE-SHIP CREATE . DOES>
@-ROT (--nxy) BOX;
: SIZE ; \ do-nothing word

Now, the usage would be (SIZE is included merely as a reminder
of what 5 means — it has no function other than to make the
deﬁnition look like an English phrase)

SIZE 5 SPACE-SHIP KLINGON <cr> OR
7135 KLINGON <cr> 0k

Of course, SPACE-SHIP is a poorly constructed deﬁning word
because it does not do what it is intended to do. Its child-word
KLINGON simply draws itself at (x, y).

What we really want is for KLINGON to undraw itself from its old
location, compute its new position according to a set of rules, and
then redraw itself at its new position This sequence of operations
would require a deﬁnition more like

:OLD.POS@ (adr--adrnxy) DUP @ OVER
2+ D@ :

eJtathNobIe—Almreaervad.

32

Chapter 2 - Programming In FORTH Scientiﬁc Forth

: SPACE-SHIP CREATE , 4 ALLOT DOES>
OLD.POS@ UNBOX NEW.POSI
OLD.POS@ BOX DROP ;

where the needed specialized operation UNBOX would be
deﬁned previously along with BOX.

§§3—2 Dlmensloned data (with Intrinsic unlts)
Here is another example of the power of deﬁning words and of
the distinction between compile-time and run-time be-
haviors.

Physical problems generally work with quantities that have
dimensions, usually expressed as mass (M), length (L) and time
(T) or products of powers of these. Sometimes there is more than
one system of units in common use to describe the same
phenomena.

For example, trafﬁc police reporting accidents in the United
States or the United Kingdom might use inches, feet and yards;
whereas Continental police would use the metric system. Rather
than write different versions of an accident analysis program it is
simpler to write one program and make unit conversions part of
the grammar. This is easy in FORTH; impossible in FORTRAN,
BASIC Pascal or C; and possible, but exceedingly cumbersome

in Adam.

We simply keep) all internal lengths in millimeters, say, and con-
vert as follo :

 

19.
20.

An example (and its justiﬁcation) of dimensioned data types in Ada is given by Do-While l ones,
Dr. Dobb’r Journal, March 1987. The FORTH solution below is much simpler than the Ada version.
This example is based on 16-bit integer arithmetic. The word '/ means “multiply the third num-
ber on the stack by NOS, keeping 32 bits of precision, and divide by TOS". That is, the stack
comment for '/is(sbc--a'blc).

ma—Pmmronm 33

:INCHES 25410 -/ ;

:FEET [25412'1UTERAL 10 ‘l;
:YARDS [25436'1LITERAL10 -/;
:CEN‘HMETERS 10 - ;

:METERS 1000 - ;

The usage would be

10 FEET. <cr> 30480k

These are more deﬁnitions than necessary, of course, and the
technique generates unnecessary code. A more compact ap-
proach uses a deﬁning word, UNITS :

: D, SWAP , , ; \IdoubIe—Iengthatin next ceIIs
:UNITS CREATE D, DOES> D@ “I;

Then we could make the table

25410 UNITS INCHES
25412 * 10 UNITS FEET
254 36 " 10 UNITS YARDS

10 1 UNITS CENTIMETERS
10001 UNITS METERS
\ Usage:

10 FEET. <cr> 3048 0k
\ 3 METERS. <cr> 300001:

This is an improvement, but FORTH lets us do even better: here
is a simple extension that allows conversion back to the input
units, for use in output:

VARIABLE <AS> \new variable
0 <AS>I \initialize to 'F"
:AS -1 <AS> I ; \set <AS> = "T'

34 Chapter 2 — Programming In FORTH Scientiﬁc Forth

:UNITS CREATE D, DOES>

0@ \ get 2 #s

< AS > @ \ get current val.
IF SWAP THEN \fIip if "true'

*I 0 <AS> I ; \convert. reset <AS>

BEHEAD' < AS > \ make it local for security”

\ unit deﬁnitions remain the same

\ Usage:
\ 10 FEET . <cr> 3048 ok
\ 3048 AS FEET . <cr> 10 ok

§§4 Advanced methods of controlllng the compiler
FORTH includes a technique for switching from compile mode
to interpret mode while compiling or interpreting. This is done

using the words ] and [ . (Contrary to intuition, ] turns the
compiler on, [ turns it off.)

One use of ] and [ is to create an “action table” that allowzs2 us to
choose which of several actions we would like to perform .

For example, suppose we have a series of push-buttons numbered
1-6, and a word WHAT to read them.

That is, WHAT waits for input from a keypad; when button #3 is
pushed, e.g., WHAT leaves 3 on the stack.

We would like to use the word BUTTON in the following way:

WHAT BUTTON

 

21. Headerless words are described in ”R, p. 3251f. The word BEHEAD' is HS/FORTH’s method
for making a normal word into a headerless one. See Ch. 5§1§§3 for further details.

22. Better methods will be described in Chapter 5.

ma-rwmmronm 35

BUTTON can be deﬁned to choose its action from a table of
actions called BUTTONS . We define the words as follows:

CREATE BUTTONSé RING-BELL OPEN-DOOR
ENTER LAUGH RY SELF-DESTRUCT [
:BUTTON 1- 2" BUTTONS + @ EXECUTE;

If, as before, [push #3, then the action ENTER will be executed.
Presumably button #7 is a good one to avoid”.

How does this work?

0 CREATE BUTTONS makes a dictionary entry BUTTONS.

e ] turns on the compiler: the previous! -deﬁned word-names
RING-BELL, etc. are looked up in the dictionary and compiled
into the table (as though we had begun with :), rather than
being executed.

a [ returns to interactive mode (as if it were :), so that the next
colon deﬁnition (BUTTON) can be processed.

o The table BUTTONS now contains the code-ﬁeld addresses
(CFA’s) of the desired actions of BUTTON .

e BUTTON ﬁrst uses 1- to subtract 1 from the button number
left on the stack by WHAT (so we can use 0—based numbering
into the table — if the ﬁrst button were #0, this would be
unneeded).

o 2" then multiplies by 2 to get the offset (from the beginning of
BUTTONS) of the CFA representing the desired action.

a BUTTONS + then adds the base address of BUTTONS to get
the absolute address where the desired CPA is stored.

a @ fetches the CFA for EXECUTE to execute.

a EXECUTE executes the word corresponding to the button
pushed. Simple!

 

Z3. TIM: safety of an execution table can be increased by making the ﬁrst (that is, the zero’th) action
WARNING, and making the ﬁrst step of BUTTON a word CHECK-DATA that maps any num-
ber not in the range 1-6 into 0. Then a wrong button number causes a WARNING to be issued
and the system resets.

§9 Strings

Chapter 2 — Programmlng In FORTH Sclendﬂc Forth

You may well ask “Why bother with all this indirection, pointers,
pointers to pointers, tables of pointers to tables of pointers, and
the like?” Why not just have nested IF ELSE THEN con-
structs, as in Pascal?

There are three excellent reasons for using pointers:

e Nested IF. . .THEN’s uickly become cumbersome and dif-
ﬁcult to decipher (TF). ey are also am (see Ch. 11).

0 Changing pointers is generally much faster than changing other
kinds of data — for example reading in code overlays to ac-
complish a similar task.

0 The unlimited depth of indirection possible in FORTH per-
rnits arbitrary levels of abstraction. This makes the computer
behave more “intelligently" than might be possible with more
restrictive languages.

A similar facility with pointers gives the C language its abstrac-
tive power, and is a major factor in its popularity.

y now it should be apparent that FORTH can do anything any

other language can do. One feature we need in any sort of
programming —scientiﬁc or otherwise — is the ability to handle
alphanumeric strings. We frequently want to print messages to
the console, or to put captions on ﬁgures, even if we have no
interest in major text processing.

While every FORTH system must include words to handle
strings(see, e.g., FTIL Ch. 9 ) —the very functioning of the outer
interpreter, compiler, etc., demands this — there is little unanim-
ity in deﬁning extensions. BASIC has particularly good string-
handling features, so HS/FORI'H and others provide extensions
designed to mimic BASIC’s string functions.

mz-PWHFOR‘I’H 37

Typical FORTH strings are Iimite to 255 characters because they
contain a count in their ﬁrst byte . The word COUNT

:COUNT DUP 1+ SWAP C@ ; (adf--nadr+1)

expects the address of a counted string, and places the count and
the address of the ﬁrst character of the string on the stack. TYPE,
a required ’79 or ’83 word, prints the string to the console.

It is straightforward to employ words that are part of the system
(such as KEY and EXPECT) to deﬁne a word like 3“ that takes
all characters typed at the keyboard up to a ﬁnal " (close-quote
—not a word but a string-terminator), makes a counted string of
them, and places the string in a buffer beginning at an address
returned by PAD”.

The word 3. ("string-emit") could then be deﬁned as
:$. COUNT TYPE ; (adr - -)
and would be used with 3“ like this:

$' The quick brown fox" < cr> ok
S. The quick brown fox ok

Since this book in not an attempt to paraphrase FIR it is strongly
recommended that the details of using the system words to devise
a string lexicon be studied there.

One might contemplate modifying the FIR lexicon by using a
full 16-bit cell for the count. This would permit strings of up to
64k bytes (using unsigned integers”), wasting 1 byte of memory
per short ( 255 bytes) string. Although few scientiﬁc applications
need to manipulate such long strings, the program that generated
the index-to this book needed to read a page at a time, and thus
to handle strings about 3—5 kbytes long.

 

24. A single byte can represent positive numbers 0-255.
25. A system variable that returns the current starting address of the “scratchpad”.

26. ma. 3.

38 Chapter 2 — Programming In FORTH Scientific Forth

§10 FORTH programming style
A FORTH program typically looks like this

\ Example of FORTH program
:WORD1 .. . ;

:WORD2 OTHER-WORDS ;
:WORDS YET-OTHER-WORDS ;

: LAST-WORD wonon ...WORD3
wonoz wonm ;
LAST-WORD <cr> \run program

Note: The word \ means “disregard the rest of this line”. It is a
convenient method for commenting code.

In other words, a FORTH program consists of a series of word
definitions, culminating in a definition that invokes the whole
shebang. This aspect gives FORTH programming a somewhat
different ﬂavor from programming in more conventional lan-

guages.

Brodie notes in TF that high-level programming languages are
considered good if they require structured, top-down program-
ming, and wonderful if they impose information hiding. Languages
such as FORTRAN, BASIC and assembler that permit direct
jumps and do not impose structure, top-down design and data-
hiding are considered primitive or bad. To what extent does
FORTH follow the norms of good or wonderful programming
practice?

§§1 Structure
The philosophy of “structured programming” entered the
general consciousness in the early 1970’s. The idea was to
make the logic of program control flow immediately apparent,

O Jdian V.Nobie — All rights reserved.

arms-Warm 39

thereby aiding to produce correct and maintainable programs.
The language Pascal was invented to impose by ﬁat the discipline
of structure. To ti? end, direct jumps (GOT Os) were omitted
from the language .

FORTH programs are automatically structured because word
deﬁnitions are nothing but subroutine calls. The language con‘
tains no direct jump statements (that is, no GOT 0's) so it is
impossible to write “spaghetti" code.

A second aspect of structure that FORTH imposes (or at least
encourages) is short deﬁnitions. There is little speed penalty
incurred in breaking a long procedure into many small ones,
unlike more conventional languages. Each of the short words has
one entry and one exit point, and does one job. This is the beaux
ideal of structured programming!

“2 "Top-down" design

ost authors of “how to program” books recommend design-

ing the entire program from the general to the particular.
This is called “top-down" programming, and embodies these
steps:

a Make an outline, ﬂow chart, data-ﬂow diagram or whatever,
taking a broad overview of the whole problem.

a Break the problem into small pieces (decompose it).
0 Then code the individual components.

The natural programming mode in FORTH is “bottom-up”
rather than “top-down” — the most general word appears last,
whereas the deﬁnitions necessarily progress from the primitive
to the complex. It is possible - and sometimes vital — to invoke
a word before it is deﬁned (“forward referencing’ ). The dic-
tionary and threaded compiler mechanisms make this nontrivial.

 

27. lronially, most programmers refuse to get along without spaghetti code, so commercial Pascal's
now include GOTO. Only FORTH among major languages completely eschews both line labels
and 6010;, making it the most structured language available.

28. The FORmula TRANsIator in Ch. 1154 uses this method to implement its recursive structure.

OWVNobIe-Aldghtsreaarved.

CMptar 2 - Programming In FORTH Scientiﬁc Forth

The naturalness of bottom-up programming encourages a some-
what different approach from more familiar languages:

0 In FORTH, components are speciﬁed roughly, and then 3 they
are coded they are immediately tested, debugged, redesigned
and improved.

0 The evolution of the components guides the evolution of the
outer levels of the program.

We will observe this evolutionary style in later chapters as we
design actual programs.

§§3 Information hiding
Information (or data) “hiding” is another doctrine of structured
programming. It holds that no subroutine should have access
to, or be able to alter (corruptlzg data that it does not absolutely
require for its own functioning .

Data hiding is used both to prevent unforeseen interactions
between pieces of a large program; and to ease designing and
debugging a large program. The program is broken into small,
manageable chunks (“black boxes”) called modules or objects
that communicate by sending messages to each other, but are
otherwise mutually impenetrable. Information hiding and
modularization are now considered so important that special
languages —Ada, MODULA-Z, C+ + and Object Pascal— have
been devised with it in mind.

To illustrate the problem information hiding is intended to solve,
consider a FORTRAN program that calls a subroutine

 

Rather like the “cell" system in revolutionary conspiracies, where members of a cell know only
each other but not the members of other cells. Mechanisms for receiving and transmitting mes-
sages between cells are double-blind. Hence, if an individual is captured or is a spy, he can
betray at most his own cell and the damage is limited.

MZ-PWhFOﬁTH ‘1

PROGRAM MAIN
some lines

CALL SUB1(arg1, ar92, , argn. mswer)
some lines

END

SUB1(X1, , Xn, Y)
some lines
Y = something
RETURN
END

There are two ways to pass the arguments from MAIN to SUBI,
and FORTRAN can use both methods.

0 Copy the arguments from where they are stored in MAIN into
locations in the address space of SUBl (set aside for them
during compilation). If the STATEMENTS change the values
X1,...,Xn during execution of SUBl, the original values in the
callin program will not be affected (because they are stored
elsew ere and were copied during the CALL).

0 Let SUBl have the addresses of the arguments where they are
stored in MAIN. This method is dangerous because if the
arguments are changed during execution of SUBl, they are
changed in MAIN and are forever corrupted. If these changes
were unintended, they can produce remarkable bugs.

Although copying arguments rather than addresses seems safer,
sometimes this is impossible either because the increased
memory overhead may be infeasible in problems with large
amounts of data, or because the extra overhead of subroutine calls
may unacceptably slow execution.

What has this to do with FORTH?

e FORTH uses linked lists of addresses, compiled into a diction-
ary to which all words have equal right of access.

0 Since everything in FORTH is a word —constants, variables,
numerical operations, I/O procedures- it might seem impos-
sible to hide information in the sense described above.

0 Fortunate] , word-names can be erased from the dictionary
after their F As have been compiled into words that call them.
(This erasure is called “beheadmg”.)

emvm—Mmm.

42 Chapter 2 — Programmhg in FORTH Scientiﬁc Forth

e Erasing the names of variables arantees they can be neither
accessed nor corru ted by unaut orized words (except through
a calamity so drea ful the program crashes).

§§4 Documenting and commenting FORTH code
FORTH is sometimes accused of being a “write-only" language.
In other words, some complain that FORTH is cryptic. I feel
this is basically a complaint against poor documentation and ~_
unhelpful word names, as Brodie and others have noted.

Unreadability is equally a ﬂaw of poorly written FORTRAN,
Pascal, C, etal.

FORTH offers a programmer who takes the trouble a goodly
array of tools for adequately documenting code.

§§4—1 Parenthesized remarks
The word ( —a left parenthesis followed by a space - says “dis- ‘
regard all following text up until the next right parenthesis in
the input stream. Thus we can intersperse explanatory remarks
within colon deﬁnitions. This method was used to comment the
Legendre polynomial example program in Ch. 1.

§§4—2 Stack comments
A particular form of parenthesized remark describes the effect of
a word on the stack (or on the ﬂoating point fstack in Ch. 3). For
example, the stack-effect cement (stack comment, for short)

( adr - - n)
would be appropriate for the word @ (“fetch”): it says @ expects I

to find an address (adr) on the stack, and to leave its contents (n) .
upon completion.

The corresponding comment for i would be

 

30. The right parenthesis, ) , is not a word but a delimiter.

(nadr--).

An fstack comment is prefaced by a double colon :2 as

(::x--f[x]).

Note that to replace parentheses within the comment we use
brackets [ ] , since parentheses would be misinterpreted. Since
the brackets appear to the right of the word ( , they cannot be
(mis-) interpreted as the FORTH words ] or [ .

With some standard conventions for names”, and standard ab-
breviations for different types of numbers, the stack comment
may be all the documentation needed, especially for a short word.

“4-3 0'09 "0° ( \ I
The word \ (back-slash followed by space) has gained favor as a
method for including longer comments. It simply means “drop
everything in the input stream until the next carriage return".
Instructions to the user, clariﬁcations or usage examples are most
naturally expressed in an included block of text with each line set

offszby\.

§§4—4 Sell-documenting code
By eliminating ungrammatical phrases like CALL or GOSUB,
FORTH presents the opportunity —via telegraphic names33 for
words — to make code almost as self-documenting and
transparent as a simple English or German sentence. Thus, for
example, a robot control program could contain a phrase like

2 TIMES LEFT EYE WINK

which is clear (although it sounds like a stage direction for Brun-
hilde to vamp Siegfried). It would even be possible without much

 

See, e.g., L Brodie, 11", Ch. 5, Appendix E.
Forthosefamiliarwithassemblylanguage,\isexactly analogousto;inassembler. But since ; is
alreadyusedtocleseeoiondeﬁnitionsinkaH, the symbol\hasbeenusedinitspiace.

The matter of naming brings to mind Mark Twain's remark that the difference between the al.
most-right word and the right one is the difference between the lightning-bug and the lightning.

cJtlthNoUe-Alrioi'ureeerved.

44 Chapter 2 — Programming In FORTH Scientiﬁc Forth

difﬁculty to deﬁne the words in the program so that the sequence
could be made English-like:

WINK LEFT EYE 2 TIMES .

§§5 Salim

Some high level languages perform automatic bounds checking
on arrays, or automatic type checking, thereby lending them a
spurious air of reliability. FORTH has almost no error checking
of any sort, especially at run time. Nevertheless FORTH is a
remarkably safe language since it fosters ﬁne-grained decomposi-
tion into small, simple subroutines. And each subroutine can be
checked as soon as it is defined. This combination of simplicity
and immediacy can actually produce safer, more predictable code
than languages like Ada, that are ostensibly designed for safety.

Nonetheless, error checking —especialiy array bounds-check-
ing— can be a good idea during debugging. FORTH lets us
include checks in an unobtrusive manner, by placing all the safety
mechanisms in a word or words that can be “vectored” in or out
as desired“.

 

34. See m for a more thorough discussion of vectoring. Brodie, TF, sugests a nice construct
called DOER MAKE that can be used for graceful vectoring.

