Chapter 11 — Symbolic Programming Scientiﬁc FORTH

and factors. However, to reduce the number of parentheses,
FORTRAN adopted a heirarchy of operators that has been fol-
lowed by all other languages that incorporate semi-algebraic
replacement statements like the above. The heirarchy is

0. FUNCTION

1. EXPONEN'TIATION ( A or u)
2. t or/

3. + or —

4. “ , ” (argument separator in lists)

The translator must both enforce these rules and resolve am-
biguities involving operators at the same heirarchical level. Thus,
e.g., does the fragment

NB‘C

mean N(B*C) or (NB)*C ? Many FORTRAN compilers follow
the latter convention, so we will maintain this tradition.

Wd issue is the function library. The FORmula
slator must recognize functions, and be able to deter-
mine whether a given function is in the standard library. In the
example above, F" recognized EXP and SIN as standard library
functions and emitted the FORTH code to invoke them. Abeauty
of FORTH is that there are several easy ways to accomplish this,
using components of the FORTH kernel.

A third issue is the ability of a true FORTRAN compiler to
perform mixed-mode arithmetic, combining INTEGER'Z, IN-
TEGER‘4, INTEGER'8, REAL‘4, REAL'S, COMPLEX'S
and COMPLEX' 16 types ad libitem. FORTRAN does this using
the information contained in the type declarations at the begin-
ning of a routine. A pure FORmula TRANslator has no such
noncontextual information available to it, hence has no way to
decide how to insert the proper FORTH words during compila-
tion. To get around this we employ the generic data and operator
conventions developed in Chapter 5 §l.

swimmer" awn-OMW 2”

"3 Pm
Let us hand-parse the example, reproduced below:

A I -15.3€7'EXP(7/X) + Z/(W-SINCI'HETA'PII 1N)/4)

Clearly, we must apply the ﬁrst rule

\<assignment> -> <subiect> n <expression>

embodied in the word < assignment > . We split at the “ = " sign,
and interpret the text to its left as a SCALAH. Since we want to
emit the phrase A FS > last, yet have parsed it ﬁrst, we have to
hold it somewhere. Clearly the buffer where we store it will be a
first-in last-out type; and by induction, last-in, first-out also. But
a LIFO buffer is a stack. Hence the fundamental data structure
needed in our parsing algorithm is a string stack. So we might
imagine that after the ﬁrst parsing step the string stack contains

 

two strings
£SIACK Notes
A FS > \ < subject >

-15.3E7*EXP(7/X) + Z/(W-SlN('l’HETA"P|/180)/4) \ < expressio

Next we apply the rule
\<expr'n> -> <term> |<term> a <axpr'n>

This breaks the top expression at the + sign between “ ) " and Z.
We should think of the two terms

-15.3E7*EXP(7/X)

and

Z/(W-SINUHETNPIMBOW)

as numbers on the ifstack; hence the code to evaluate each should
be emitted before the addition operator (that is, these expres-
sions are higher on the string stack than the addition operator
0 +). We adopt a rule that the right term is pushed before the
left, so the Sstack now looks like

emvuounm-umm.

Chapter 11 - Symbolic Programming Sclemlﬂc FORTH

 

SSIAQK Notes

A FS > \ < subject >
Z/(W-SIN(THETA*PI/180)/4) G + \ <term >
-15.3E7*EXP(7IX) \ < term >

We now anticipate a new problem: suppose we have somehow —
no need to worry about details yet — emitted the code for the
< term > -15.3E7*EXP(7/X) on top of the Sstack. Then we
would have to parse the line Z/(W-SINCI’ HETA'Pl/1 80)/4) G + .
Assuming the program knows how to handle the ﬁrst part,
Z/(W-SIN(THETA"PI/180)/4), how will it deal with the G + ?
We do not want to use the space as a delimiter (an obvious out)
because this will cause trouble with A FS > .

The difficulty came from placing 6+ on the same line as
—1 5.3E7‘EXP(7/X). What if we had placed the operator on the
line above, as in

 

SSIACK Notes

A FS > \ < subject >
G + \ operator
Z/(W-SINUHETA'PI/180)/4) \ < term >
-15.3E7*EXP(7/X) \ < term >

Eventually we see this merely exchanges one problem for another
of equal difficulty: How do we distinguish a < factor > or
< term > that contains no more operators or functions — and is
therefore ready to be emitted as code — from the operator G +,
which contains a “ +” sign? Now we need complex expression
recognition, which will lead to a slow, complicated program.

When this sort of impasse arises (and I am pretending it had

been realized early in the design process, although the dif-
ﬁculty did not register until somewhat later) it signals that a key
issue has been overlooked. Here, we failed to distinguish FORTH
words, FS > and G +, from FORTRAN expressions. We have, in
effect, mixed disparate data types (like trying to add scalars and
vectors). Worse, we discarded too soon information that might

have been [BCfUI at a later stage. This leads to a programming tip,
a la Brodie :

I m: Never discard information. You might need it later.

Phrased this way. the solution becomes obvious: keep the
operators on a separate stack. whose level parallels the expres-
sions. So we now envision an expression stack and an operator
stack, which we call 13/8 and 0/5 for short. On two stacks,

 

E/S Q15 Notes
A FS > \ < subject >
Z/(W-SINCI‘HETA'Pi/180)/4) G + \ < term >
—15.3E7"EXP(7/X) NOP \ < term >

Why the NOPs (“no operation”) on the 0/8? We want to keep
the stack levels the same (so we do not have to check when
POPping off code strings); we thus have to put NOP on the 0/5
to balance a string on the BS.

The IDS now contains a < term > , so we apply the rules
\<function> -> <id> <arglist>
\<term> -> <iactor> | <factor> 96 <term>

\<factor>-> <id>| <fp#>| (<expr’n>) |<func>

We note there is an operator at the “ 96 " priority level (the “a"
in the TOS). We split the top < term > at this point, issuing a G'.

 

EIS QLS_N.QIQ§
A FS > \ < subject >
Z/(W-SINO’HEI'A'Pl/180)/4) G + \ < term >
EXPO/X) G‘ \ (term >
-1 5.367 NOP

 

23. Leo Brodie, mammary (Prentice-Hall, Inc, NJ, 1984).

Chapter 11 - Symbolic Programming Sclenrlﬂc FORTH

The parsing has now reached a turning point: the top string on
the E/S can be reduced no further. The program must recognize
this and emit the corresponding line of code (sec Ch. 5):

% —15.3E7 REALM F>FS

 

leaving

E18 018 Notes
A FS > \ < subject >
Z/(W—SIN (T HETA*P|/180)/4) G + \ < term >
NULL 6*
EXP(7/X) NOP \ < function >

What is NULL and why have we pushed it onto the E/S? Simply,
it is not yet time to emit the 6" so we have to save it; however,
we have another operator, G +, to associate with Z/(W-
SlN(THETA*PI/180)/4) . Thus we have no choice but to deﬁne a
placeholder for the 13/5, analogous to NOP on the 0/5.

S now contains a function. Assuming we can recognize it as
such, we want to check that it is in the library and put the
correct operator on the 13/5. Thus we want to decompose to

 

E15 018 Notes
A FS > \ < subject >
Z/(W-SIN(THETA*P|/180)/4) G + \ < term >
NULL 6*
NULL GEXP \ < function >
(7 IX) NOP \ < arglist >

The parentheses around the <arglist> on TOS serve no pur-
pose, so drop them.

We see, once again, an operator of the priority-level 96 (the “I”
between 7 and X), so we again apply the rule

\<term> -> <factor> | <factor> 9i. <term>

to obtain

El: 013 Item

A F8 > \ < subject >
ZlM-SlNCFHETA'Pi/iwyﬂ G + \ < term >
NULL G“

NULL GEXP

X G] \ < id >

7 NOP \ < ip# >

Once again we can emit a number, so we do it:

96 7 REAL'B F> FS

Wait! Why did we say REALM with —15.3E7, but REAL'B with
7 just now? Can’t we make up our minds? The answer is that we
want to respect precision over-rides via FORTRAN's E (single
precision, so we say REALM) or D (double precision — REAL'B)
exponent preﬁxes. However, where we are free to choose, it
makes sense to keep maximum precision.

We continue, emitting the next simple items on the Sstack:

X G/ GEXP G‘

 

leaving

E18 018 Notes
A FS > \ < subject >
Z/(W-SlNCI’HETA'PI/180)l4) G + \ < term >

Once again we ﬁnd the most exposed operator to be “ / which
we split with the rule

\<term> -> <factor> | <factor> 96 <term>

 

E/S QLS__N91§§

A FS> \ <subject>
NULL G + \ < term >
(ZW~SIN(THETA*Pi/180)/4) Slop \ ( < expr > )

Chapter 11 - Symbolic Programming Scientiﬁc FORTH

Emit the T082
2 > PS
and apply the rule (ﬁrst drop the parentheses)

\<expr'n> -> <term> | <term> a <expr'n>

 

EIS Q15 Nona
A FS > \ < subject >
NULL G + \ < term >
NULL G/
—SIN(THEl'A*PI/180)/4 G +
W NOP

Why did we issue G + and keep the leading “—” sign with SIN?
Simple: any 9th grader can tell the difference between a “—”
binary operator (binop) and a “—” unary operator (unop) in an
expression. But, while not impossible, it is unnecessarily difﬁcult
to program this distinction. The FORTH philosophy is “Keep it
simple!” Simplicity dictates that we embrace every opportunity
to avoid a decision, such as that between “—” binop and “-" unop.
The algebraic identity

X—YEX+(—Y)

lets us issue only G + , as long as we agree always to attac “—”
signs as unops to the expressions that follow them. Eventually,
of course, we shall have to deal with the distinction between
negative literals (-15.3E7, e.g.) and negation of variables. The
first we can leave alone, since the literal-handling word 96 (“treat
the following number as ﬂoating point and put it on the 87stack”)
surely knows how to handle a unary “—" sign; whereas the second
case will require us to issue a strategic GNEGATE.

A consequence of this method for handling “-” signs is that the
compiler will resolve the ambiguous expression

—X" =9 -(X") or (—X )Y

Mir-WW 295

in favor of the former alternative. if the latter is intended, it must
be speciﬁed with explicit parentheses.

After sending forth the phrase
W > PS

the leading “-" preceding SIN( ...)/4 must be dealt with. To
preserve the proper ordering on emission we will want a word
LEADING- that puts the token for GNEGATE on the 0/8 and
moves the string SiNCl'i-iETA'PI/i 00)“ to the TOS, issuing a
NOP on the BS, obtaining

 

E18 018 Ngtgs
A FS > \ < subject >
NULL G + \ < term >
NULL 6/
NULL G +
NULL GNEGATE
SIN (THETA'Pl/1 80)/4 NOP

The next exposed operator is at“ 96 " -level. We apply < term >
once more, to get:

 

EIS OLS Notes
NULL GNEGATE
4 G/
SINO‘HETA'PIHBO) NOP \( <expr'n> )

After handling the function as before we ﬁnd the successive stacks
and FORTH code emissions

 

E/S MS Notes
A FS > \ < subject >
NULL G + \ < term >
NULL 6/
NULL G +
NULL, GNEGATE
4 GI
NULL GSIN

(THETA'PI/180) NOP

Chapter 1 t - Symbolic Programming Scientiﬁc FORTH

 

51$ 0/8 Joins
A FS > \ < subject >
NULL G + \ < term >
NULL 6/
NULL G +
NULL GNEGATE
4 GI
NULL GSIN
180 6/
PI 6*
THETA NOP

THETA >FS PI >FS G“ 96180 REAL*8 F>FS
G/ GSIN %4 REAL‘B F>FS G/ GNEGATE G+
G/ G+ AFS> ok

§§4 Coding the FORmula TRANslator

e proceed in the usual bottom-up manner. The ﬁrst question

is how to define the Sstack. In the interest of brevity, I chose
not to push the actual strings on the E/S, but rather pointers to
their beginnings and ends. By using a token to represent the
operator, we can deﬁne a 6-byte wide stack which will point to
the text of interest (which itself resides in a buffer), and will hold
the token for the operator at the current level. This way only one
stack is pushed or popped and the levels never get out of
synchronization.

Again at the lowest level, we can develop the components that
recognize patterns, e.g., whether a piece of text is a ﬂoating point

number. The word that does the latter is fp#?, already described
in §2§§1.

A function is defined by the rule

\<arglist> -> ( <expr'n> {, <expr'n>}")
\<function> -> <id> <argl|st>

We may therefore identify a function by splitting at the ﬁrst left
parenthesis,

OJUthNobie 1N2-Alirightlmervod.

sand scrum new
1- Beam 1mm ASCII ()- ,ii (
ooup - a> UNTIL'

and then applying appropriately deﬁned FSMs to determine
whether the pieces are as they should be.

:<thction>($endSbeg--i)
DUP>R >( (--Send$beg')
UNDER 1- Fi> <id>

—ROT SWAP <arglist> AND ;

The FSM < argllct > must be smart enough to exclude cases such
as

SIN(A + B)/(C-D)
and
SIN(A + B)/EXP(C-D)

that is, compound expressions that might contain functions; it
must also correctly recognize, e.g.,

SIN((A + B)/EXP(C-D))

as a function.

In FORTH there is no distinction between library functions and
functions we deﬁne ourselves. In either case, the protocol deﬁned
in Chapter 8 will work ﬁne. Thus the code generator for < func-
tion > emits the code

USE( fn.name arg1 argz argN F(x)

What, however, do we do about translating standard FORTRAN
names such as SIN, COS and EXP to their generic FORTH
equivalents? The simplest method deﬁnes words with the names
of the FORTRAN library functions. The FORTH-83 word FIND
locates the code-ﬁeld address of a name residing in a string. Thus
we could have (note: .GSIN is a CONSTANT containing a token)

.GSIN CONSTANT sm \etc.

omvmtm-umm.

298 Chapter 11 — Symbolic Programming Scientiﬁc FORTH

:LIBRARY? ($end$beg--cta | 0)
—ROT UNDER — DUP>R
PADt+ SWAP CMOVE R> PAD CI \makes
PAD FIND (--cia n) o= NOT AND ;

now we can deﬁne function! which, assuming pointers to the
< id > and < arglist > are on the stack, rearranges the Sstack like

 

 

this:
BS QIS Notes
(argt, argz, argN) .F(X) \ an op.
NULL .iib_name \ if library function
or, if it is a user-deﬁned function, like this:
E18 018 Notes
(arg1, argZ, argN) .F(X) \an op.
name NOP \ user function

The code that does all this is

: function! ($end2 $beg2 $end1 $beg1 - -)
.F(X) $push \ push arglist
DDUP LIBRARY? DUP 0=
IF DROP .NOP $push \userfn
ELSE EXECUTE \inlib.
NULL ROT $PUSH DDROP
THEN ." USE( " ;

For the program itself24 we work from the last word, < aslgn-

ment > , to the ﬁrst (which we do not know the name of yet).
We shall describe the program in pseudocode only, in the interest
of saving space. Clearly,

: < assignment > \ input $ assumed in buffer
<subj> = <expr> \splitat "=" (- -t)
IF subjl THEN \ put Subj and its code on $staci<
.NOP $push ; \ then put expr on Sstack

 

24. File FT RAN .FI‘ H on the proyam diskette.

Certain decisions need to be made here: for example, do we want
F' to be able to parse an expression that is not an assignment (that
is, generating code which evaluates the expression and leaves the
result on the ifstack)? We allowed this with the IF...THEN.

Next we pseudocode < oxproeeion >:
: <expression> empty? IF EXIT THEN
59°F

<trm>&<expr> (--f) \splitat].
IF trm&exprl RECURSE
ELSE NULL ROT $push
.NOP $push <term>
THEN ;

Defined recursively in this way, < oxpreoolon > will keep
working on the TOS until it has broken it up into term 5.

We similarly deﬁne < term > recursively, so it will break up any
term 5 into all their factors. It should also recognize < arglist > 5.
Thus:

: <term> empty? IF EXIT THEN

$pop < arglist >
IF arglist! < expression > EXIT THEN
<factor>%<term> (--f)\splitat%="/'

IF fct%trml RECURSE
ELSE .NOP $push <factor> \term = factor
THEN ;

And finally, we define < factor > , again recursively,

: <factor> empty? IF EXIT THEN \done
SPOP <fp# > \ fp#?
IF fp#I RECURSE EXIT THEN
leading -?
IF leading—I < expression > \ forward ref.
EXIT THEN
< id > IF idI < expression > \ forward ref.
EXIT THEN
<f>"<f> \exponent’?
IF f"fI RECURSE RECURSE
EXIT THEN
\ oont'd

OWVNoUelﬂZ-Almmorved.

Chapter 11 - Symbolic Programming Scientiﬁc FORTH

< function >
IF functionl < expression > \ forward ref.
EXIT THEN

(< expression >) \ expression inside ( )?

IF exposel < expression > \ forward ref.
ELSE ." Notafactorl' ABORT THEN ;

Note the forward references found in <factor>; since <ex-
pression > is deﬁned later, we must use vectored execution or
some similar method to permit this recursive call.

With this we conclude our discussion of rule-based programming.
The complete code for the FORmula TRANslator is too lengthy
to print, hence it will be found on the included diskette.

