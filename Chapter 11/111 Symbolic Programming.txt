\chapter{Symbolic Programming}

Contents
51 Rules 260
52 Tbols 262
§§1 Pattern recognizers 262
§§2 Finite state machines 265
§§3 FSMs in FORTH 268
§§4 Automatic conversion tables 271
53 Computer algebra 273
591 Stating the problem 273
552 The rules 275
553 The program 276
54 FORmula TRANslator 284
551 Rules of FORTRAN 285
552 Details of the Problem 286
§§3 Parsing 289
§§4 Coding the FORmula TRANslator 296

All symbolic programming is based on rules — a set of generalized instructions that tells the computer how to transform one set of tokens into another. An assembler, \textit{e.g.}, inputs a series of machine instructions in mnemonic form and outputs a series of numbers that represent the actual machine instructions in executable form. A FORTH compiler translates a deﬁnition into a series of addresses of previously deﬁned objects. Even higher on the scale of complexity, a FORTRAN compiler inputs high-level language constructs formed according to a certain grammar and outputs an executable program in another language such as assembler, machine code or C.

What do rules have to do with scientific problem-solving? The crucial element in the rule-based style of programming is the ability to specify general patterns or even classes of patterns so the computer can recognize them in the input and take appropriate action.

For example, in a modern high-energy physics experiment the rate at which events (data) impinge on detectors might be 10^7 discrete events per second. Since each event might be represented by 5-10 numbers, the storage requirements for recording the results of a search for some rare process, lasting 3-6 months of running time, might be 10^16 bytes, or 10^7 high-capacity disk drives! Clearly, so much storage is out of the question and most of the incoming data must be discarded. That is, such experiments demand extremely fast filtering methods that can determine - in 10-20$\mu$sec — whether a given event is interesting. The criteria for “interesting” may be quite general and may need to be changed during the running of the experiment. In a word, they must be speciﬁed by some form of pattern recognition program rather than hard-wired.

Another area where pattern recognition helps the scientist is computer algebra. Closely related is the ability to translate mathematical formulae into machine code. So far we have stressed a FORTH programming style natural to that language, namely postfix notation, augmenting it primarily for readability or abstracting power. It cannot be denied, however, that sometimes it is useful simply to be able to write down a mathematical formula and have it translated automatically into executable form. This chapter develops the tools for symbolic programming and illustrates their use with a typical algebra program and a simple FORmula TRANslator.

\subchapter{Rules}

Before we can specify rules we need a language to express them in. We need to be able to describe the grammar of the rules in some way. The standard notation states rules as regular expressions\footnote{See A.V. Aho, R. Sethi and J.D. Ullman, \textit{Compilers:...} (Addison-Wesley, Reading. 1988).}. The following rules describing some parts of FORTRAN illustrate how this works.

\begin{code}

\Rules for FORTRAN

\NOTATION:
\|              -> "or"
\^              -> "unlimited repetitions"
\^n             -> "0-n repetitions"
\Q              -> "empty set"
\&              -> + | -
\%              -> * | /
\<d>            -> "digit"

\NUMBERS:
\<int>          -> {-|Q} {<d> <d> ^8}
\<exp't>        -> {dDeE} {&|Q}{<d> <d> ^2} | Q
\<lp#>          -> {-|Q}{ <d> | Q} . <d> ^ <exp't>

\FORMULAS:
\<assign>       -> <subj> = <expression>
\<id>           -> <letter> {<letter>|<d>}^6
\<subject>      -> <id> {<idlist> | Q}
\<idlist>       -> ( <id> {, <id> } ^)
\<arglist>      -> ( <expr'n> {, <expr'n>}")
\<func>         -> <id> <arg|ist>
\<expr'n>       -> <terrn> | <terrn> a <expr'n>
\<terrn>        -> <fctr>|<fctr> 96 <trm> | <fctr>“<fctr>
\<factor>       -> <id> | <tp#> |(<expr'n> )| (tum)

We use angular brackets “ < ”, “ > " to set off “parts of speech”
being deﬁned, and arrows “- > ” to denote “is defined by”. Other
notational conventions, such as “ | ” to stand for “or”, are listed in
the “NOTATION" section of the rules list, mainly for mnemonic
reasons. A statement such as

\<int> -> {-|Q}<d><d>"8

therefore means “an integer is deﬁned by an optional leading
minus sign, followed by 1 digit which is in turn followed by as many
as 8 more digits". Similarly, the phrase

\<assign> -> <subj>= <expression>

means “an assignment statement consists of a subject — a symbol
that can be translated into an address in memory - followed by
an equals sign, followed by an expression". Literal symbols —
parentheses, decimal points, commas — are shown in bold type.

OJUUVNebletm-Almw.

262

§2 Tools

Cllptertt-SymbollcProgrummlng SckndﬂcFOR

Note that some of these deﬁnitions are recursive. A statemem
such as

\<expr'n> -> <terrn> | <terrn> a <expr'n>

seems to be defined in terms of itself. So it is a good bet the
program that recognizes and translates a FORTRAN expression
will be recursive, even if not explicitly so.

In order to apply a rule stated as a regular expression, we need

to be able to recognize a given pattern. That is, given a string,
we need —say— to be able to state whether it is a ﬂoating point
number or something else. We want to step through the string,
one character at a time, following the rule

\<fp#> ->{-|Q}{{d.| .d Id} (1" exp't

This pattern begins with a minus or nothing, followed by a digit
and a decimal point or a decimal point and a digit or a digit with
no decimal point, followed by zero or more digits, then an ex-
ponent.

§§1 Pattern recognizers

One often sees pattern recognizers expressed as complex logic

trees, i.e. as sequences of nested conditionals, as in Fig. 11-1
on page 263 below. As we see, the tree is already ﬁve levels deep,
even though we have concealed the decisions pertaining to the
exponent part of the number in a word exponent?. When
programmed in the standard procedural fashion with
IF...ELSE...THEN statements, the program becomes too long

Own—WW

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Fig. 11-1 Logic roe for <ﬂoatlng point I >

 

264

  
  
  
  
 

Chapter 11 - Symbolic Programming Sclentlﬂc FORT

and too czomplex either for easy comprehension or for easy main
tainance .

It has been known for many years that a better way to app,
general rules — e.g. , to detemiine whether a given string conforms
to the rules for “floating point number”— uses ﬁnite state
machines (FSMs —we deﬁne them in §2 “2 below). Here is an
example, written in standard FORTH:

\ determine whether the string at Sadr is a fp#
:skip— (adr--adr') DUP C@ ASCII- = - ;
:skip_dp (adr- - adr') DUP C@ ASCII. = — ;
\ NOTE: these “hacks“ assume “true” = -1.
:digit? (char--f) ASCIIS ASCIIO wn'HIN ;
: skip_dig ( adr2 adr1 - - adr2 adr1') 1‘
BEGIN DDUP > OVER 0@ digit? AND ‘.
WHILE 1+ REPEAT ; \... cont'd below
:dDeE? (char- -f) 95 AND \->uppercase
DUP ASCII D = SWAP ASCII E = OR ;

i
I

: skip_exponent ; \ this deﬁnition shown below
:fp#? ($adr--f)
DUP O OVER COUNT + Cl \add terminator
DUP C@ 1+ OVER Cl \count =count+1

COUNT OVER + 1— SWAP (--$end$beg)
skip— skip_dig skip_dp skip_dig
skip_exponent

UNDER = \$beg' = $end?

SWAP C@ 0: AND ; \char[$beg']=terminal?

The program works like this:

0 Append a unique terminal character to the string.

a If the ﬁrst character is “—” advance the pointer 1 byte, otherwise
advance 0 bytes.

 

These defects of nested conditionals are generally recognized. Commercially available CASE
tools such as Stirling Castle’s Logic Gem (that translates logical rules to conditionals); and
Matrix Software's Matrix Layout and AYECO, Inc.'s COMPEDITOR (that translate tabular rep-
resentations of PSMs to conditionals in any of several languages) were originally developed as in-
house aids.

0 Skip over any digits until a non-digit is found.
0 If that character is a decimal point skip over it.
0 Skip any digits following the decimal point.

e A ﬂoating point number terminates with an exponent formed
according to the appropriate rule .261). skip expo-eat ad-
vances the pointer t rough this (su )string, or else halts at the
ﬁrst character that fails to ﬁt the rule.

a Does the initial pointer (Sbeg') now point to the calculated end
of the string (Send)? And is the last character ( char[$beg;] )
the unique terminal? If so, report “true”, else report “false .

We deferred the deﬁnition of skip_exponent. Using conditionals
it could look like

: skip_exponent (adr - - adr')
DUP C@ dDeE? IF 1+ ELSE EXIT THEN
skip— skip+
DUP C@ digit? IF 1+ ELSE EXIT THEN
DUP C@ digit? IF 1+ ELSE EXIT THEN
DUP C@ digit? IF 1+ ELSE EXIT THEN ;

which,as we see in Fig. 11-2 below, has nearly as convoluted a
logic tree as Fig. 11-1 on page 263 above.

§§2 Finite state machines

Just as we needed a FSM to achieve a graceful deﬁnition of

fp#?, we might try to deﬁne skip_exponent as a state machine
also. This means it is time to deﬁne what we mean by ﬁnite state
machines. (We restrict attention to deterministic FSMs.) A ﬁnite
state macliine3'4 is a program (originally it was a hard-wired
switching circuit ) that takes a set of discrete, mutually exclusive

 

1“!"

R. Sedgewick, Algorithms (Addison-Wesley Publishing Co., Reading MA 1983) p. 1576'.

A.V. Aho, R. Sethi and JD. Ullman, Compilers: Principles, TooLr and Techniques (Addison
Wesley Publishing Company, Reading, MA, 1988).

Zvi Kohavi, Sukkot; and FiniteAutanm May, 2nd ed. (McGraw-Hill Publishing Co., New

York, 1973).

ChapterH-SymbollcProg'anm SclentlﬂcFORmr

 

 

WP-
skip+

 

 

Yes

 

 

1 +
Yes digit?

 

EXIT

 

 

 

Fig. "-2 Logic tree for <exponent>

inputs and also maintains a state variable that tracks the history
of the machine’s inputs. According to which state the machine is
in, a given input will produce different results. The FSM program
is most easily expressed in tabular form, as in Table 11-1, which
we interpret as follows:

a each major column heading is an input.

a the inputs must be mutually exclusive and exhaustive; to ex-
haust all possibilities we include “other”.

0 each row represents the current state of the machine.
0 each cell contains an action, followed by a state-transition.

imam Mil-BMW 207

Wit-imamwmm(aim'mm’

 

mm m at slid!
Sm: e

l
0 Next 5 1+ 1 Error 5 Next 5
1 Next 5 Next 5 1+ 2 1+ 3
2 Next 5 Next 5 Next 5 1+ 3
3 Next 5 Next 5 Next 5 1+ 4

4 Next 5 Next 5 Next 5 1+ 5

 

 

 

The tabular representation of a FSM is much clearer than the

logic diagram, Fig. 11-2. Since the inputs must be mutually
exclusive6 and exhaustive7, there are never conditions that cannot
be fulﬁlled —that is, leading to “dead" code— as frequently
happens with logic trees (owing to human frailty). This means the
chance of introducing bugs is reduced by FSMs in tabular form.

FORTRAN, BASIC or Assembler can implement FSMs with
computed GOTOs. In BASIC, e.g.,

DEF SUB FSM (cs. adress%)

I66 =0 ' convert input to column #
C$=UCASE (CS)

IFC$="D' OR C$='E' THEN k%=1

IFC$='+' OR C$="-' THEN k96=2

IF ASC(C$) > = 48 AND ASC(C$) < =57 THEN k%=3
' cont'd

 

6. "Mutuallyexclusive"meansonlyoneinputatatimeeanbetrue.
7. “Elinustive”meanseverypoasﬂeinputmustberepresented.

emvmrm-Mmm.

Chapter 11 -Symbollc Programming SclenﬂﬂcFom

' begin FSM proper
ON state% *3 + k% GOTO
(O,1,2,,345,,,,6789,10,,1112,13,14,15,1617,18,19)
state%= S
adress% = adress% +1 :state% = 1
CALL Error: state96 = 5 'row
state%=5
state%=5
state%=5
adress% = adress% +1 :state% = 2 ' row 1%
adress% = adress% +1 :state% = 3 ‘5
...... etc.

$999999???

16:state%=5

...... etc....... 'row4
19: adress% = adress% +1 : state% = 5
END SUB

 

The advantage of FSM construction using computed GOTOs is
simplicity; its disadvantage is the linear format of the program
that hides the structure represented by the state table, 11-1.
CASE statements —as in C, Pascal or QuickBASIC— are no
clearer. We can use a state table for documentation, but the
subroutine takes more-or-less the above form.

§§3 FSMs In FORTH
In the preceding FORTH example we synthesized the FSM from
BEGIN. ..WH|LE. . .REPEAT loops. FORTI-I’s lack of line-
labels and GOTOs (jumps) imposed this method, producing code
as untransparent as the BASIC version. The Eaker CASE state-
ment can streamline the program,

CASE: ADVANCE? NEXT 1+ ;CASE
:1digit DUP C@ digit? ABS ADVANCE?;
: skip_exponent (adr - - adr')
DUP C@ dDeE? IF 1+ ELSE EXIT THEN
skip— skip+
1digit 1digit 1digit ;

(three of four lF...ELSE...THENs have been factored out and
disguised as CASE: ;CASE), but this does not much improve
clarity. We still need the state transition table to understand the
program.

oJUIanVNobleiwz-Allrlghtsreserved.

Mmm

Mil-WW 200

Various authors have tried to improve 3333“ in FORTH using
what amount to line-labels and OO'TOss' .The resulting code
is less elegant than the BASIC version shown above.

Whenever we reach a dead end, it is helpful to return to the
starting point, restate the problem and re-examine our basic
assumptions One fact our preceding false starts make abundantly
clear is that nowhere have we used the power of FORTH. Rather,
our attempts merely imitated traditional languages in FORTH.

But FORTH is an endlessly protean language that lends itself to
any programming style. Ideally FORTH relies on names so cun-
ningly chosen that programs become self-documenting-
readable at a glance.

Since state tables clearly document FSMs, it eventually occurred
to me to let FORTH compile the state table —representing an
FSM — directly to that FSM!

Compilation implies a compiling word; after some experimen-
tation1 I settled on the following usage

 

4 WIDE FSM: (exporters)

\lnpu: | other | dDeE | +/— I did! i
\state: ———————————————————————
(0) NEXT >5 1+ >1 Error >5 NEXT >5
(1) NEXT >5 NEXT >5 1+ >2 1+ >3
(2) NEXT >5 NEXT >5 NEXT >5 1+ >3
(3) NEXT >5 NEXT >5 NEXT >5 1+ >4
(4) NEXT >5 NEXT >5 NEXT >5 1+ >5 ;

 

 

 

Fig. 11"! Form 0! a FOR TH ﬁnite state machine

 

was»

I . Basile, J. FORTHAppl. and Res. 1,2 (1982) 76-78.
E. RawsonJ. FORTHAppl. and Res. 3,4 (1986) 45-64.
0. D.W. Berrian, Prue. 1989 Rochester FORTH Con}: (Inst. for Applied FORTH Res, Inc.,

Rochester, NY 1989) p. 1-5.

11. The

at process is described in detail in my article “Avoid Decisions”, Computers in

Physics 5,“ (1991) 386.
12. The FORTH word NEXT is the equivalent of N01’ in assembler.

OthnVNobIemsz—Alnghtsresarved.

270

  
 
  
   
  

Chapter 11 —Symbollc Programming SclentlﬂcFOli

The new deﬁning word FSM: has a colon “ : " in its name
remind us of its function. Its children clearly must “know”
many columns they have. The word WIDE reminds us the new
created FSMs incorporate their own widths.

The column labels and table headers are merely comments fo
lowing “ \ ”; the state labels “ (0) ", “ (1 ) ", etc. arealso co
ments, delineated with parentheses. Their only purpose "
readability.

The actions _ NEXT, Error, 1 + -—in Fig. 11-3 are obvious: they;
are simply previously-deﬁned words. But what about the state:
transitions “ > 1 ", “ > 2 ”, ? The easiest, most mnemonic and.1

natural way to handle state transitions deﬁnes them as CON»
STANTs

 

O CONSTANT >0

1 CONSTANT >1

2 CONSTANT >2
etc.

which are also actions to be compiled into the FSM. This follows the:
general FORTH principle that words should execute themselves”..

11 Chapter S§2§§6 we used components of the compiler, par‘

ticularly the IMMEDIATE word ] (“switch to compile mode”),
to create self-acting jump tables. We apply the same method here:
The deﬁning word FSM: will CREATE a new dictionary entry,
build in its width (number of columns) using “ , ”, and then
compile in the actions and state transitions as cfa’s of the ap-
propriate words.

The runtime code installed by DOES> provides a mechanism
for ﬁnding the addresses of action and state transition cor-1
responding to the appropriate input and current state (that is, in}
the cell of interest). Then the runtime code updates the state.

 

13. That is, we should not continually reinvent interpreters equivalent to the FORTH interpreter. i

Form-1 Mil—WW 271

11) slow nesting of FSMs (Le., compiling one into another), we
incorporate the state variable for each child FSM within its data
structure. This technique, using one extra memory cell per FSM,
protects the state from accidental interactions, since if state has
no name it cannot be invoked inadvertamly.

The FORTH code that does all this is

:WIDE O;
:FSM: widthon) CREATE ,,]
DOES> coI#--)

UNDER D@ (--adrcol#widthstate)
* + 1+ 4' (--adroi‘lset)
OVER+ (--adr adr')
DUP@ SWAP2+ (--adr[adr'] adr'+2)
@EXECUTE (--adr[adr'] state')

ROT I EXECUTE ;

O CONSTANT >0

1 CONSTANT >1

2 CONSTANT >2
.. etc.

We are now in a position to use the code for (exponent)
(deﬁned' m Fig. 11-3 on page 269 above) to deﬁne the key

word skip_exponent appearing in fp#?. The result 1s

: skip exponent ( adr - - adr’)

' (exponent) OI \initialize state

BEGIN DUP C@ DUP (- - adr char)
dDeE? ABS OVER \input -> coI#
+/—? 2 AND + SWAP
digit? 3 AND + (--adrcol#)

' (exponent) @ \get state

5 < \ not done?

WHILE (exponent) REPEAT ;

554 Automatic converslon tables
Our preceding example used logic to compute (not decide!) the
conversion of input condition to a column number, via

(- - char) dDeE? ABS OVER

+/-? amp + SWAP
digit? amp + (-~col#)

emvmrm-me.

272

CMptarH—Symbollcl’rogrammhg SclentlﬂcFORTH

When the input condition is a character, it is usually both faster
and clearer to translate to a column number using a lookup table
rather than tests and logic. That is, we can trade increased
memory usage for speed. If a program needs many different
pattern recognizers, it is worth generating their lookup tables via
a deﬁning word rather than crafting each by hand.

:TABLE: (- - #bytes)
CREATE HERE (- - #bytes tab[0] )
OVER ALLOT \ allot #bytes in dictionary
SWAP 0 FILL \ initialize to all 0’s
DOES > + C@ ; ( n tab[0] - - [tab[n]])

: install (col# adr cham char.1 - -) \ fast ﬁll
SWAP 1 + SWAP
DO DDUP I+ Cl LOOP DDROP ;

Here is how we deﬁne a new lookup table:

128 TABLE: [exp] \ deﬁne 128-byte table
\ modify certain chars
\ Note: all unmodiﬁed chars return col# 0

1 ASCII d ' [exp] + C! \col# 1
1 ASCII D '[exp] + Cl
1ASCII 9 '[exp] + Cl
1 ASCII E ' [exp] + Cl

2ASCII + '[exp] + Cl \col#2
2ASC|| — '[exp] + Cl

3 '[exp] ASC|l9 ASCIIO install \col#3

With the lookup table [exp], skip_exponent becomes faster
and more graceful,

: skip_exponent (adr - - adr')

' (exponent) OI \ state =0

BEGIN DUP C@ (- - adr char)
[exp] (- - adr col#)
’ (exponent) @ (- - adr col# state)
5 < \ not done?

WHILE (exponent) REPEAT ;

at a cost of 128 bytes of dictionary space. If dictionary space
becomes tight, it would be perfeme simple to export the lookup

OJUthNoﬂOIM—Aldoﬂamownd.

