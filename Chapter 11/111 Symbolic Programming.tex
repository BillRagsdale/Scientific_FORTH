\documentclass{book}
\usepackage{blindtext}
\usepackage[scaled]{helvet}
\usepackage[utf8]{inputenc}
\usepackage[undotted]{minitoc}
	\dominitoc[n]
	\nomtcrule
\usepackage{listings}
\usepackage{hyperref}


\let\oldFootnote\footnote
\newcommand\nextToken\relax

\renewcommand\footnote[1]{%
    \oldFootnote{#1}\futurelet\nextToken\isFootnote}

\newcommand\isFootnote{%
    \ifx\footnote\nextToken\textsuperscript{,}\fi}



\begin{document}
\dominitoc
\tableofcontents
\chapter{Symbolic Programming}
\minitoc

Contents
- Rules 260
- Tools 262
--1 Pattern recognizers 262
--2 Finite state machines 265
--3 FSMs in FORTH 268
--4 Automatic conversion tables 271
53 Computer algebra 273
591 Stating the problem 273
552 The rules 275
553 The program 276
54 FORmula TRANslator 284
551 Rules of FORTRAN 285
552 Details of the Problem 286
--3 Parsing 289
--4 Coding the FORmula TRANslator 296

All symbolic programming is based on rules --- a set of generalized instructions that tells the computer how to transform one set of tokens into another. An assembler, \textit{e.g.}, inputs a series of machine instructions in mnemonic form and outputs a series of numbers that represent the actual machine instructions in executable form. A FORTH compiler translates a definition into a series of addresses of previously defined objects. Even higher on the scale of complexity, a FORTRAN compiler inputs high-level language constructs formed according to a certain grammar and outputs an executable program in another language such as assembler, machine code or C.

What do rules have to do with scientific problem-solving? The crucial element in the rule-based style of programming is the ability to specify general patterns or even classes of patterns so the computer can recognize them in the input and take appropriate action.

For example, in a modern high-energy physics experiment the rate at which events (data) impinge on detectors might be $10^{7}$ discrete events per second. Since each event might be represented by 5-10 numbers, the storage requirements for recording the results of a search for some rare process, lasting 3-6 months of running time, might be $10^16$ bytes, or $10^7$ high-capacity disk drives! Clearly, so much storage is out of the question and most of the incoming data must be discarded. That is, such experiments demand extremely fast filtering methods that can determine - in 10-20$\mu$sec — whether a given event is interesting. The criteria for "interesting" may be quite general and may need to be changed during the running of the experiment. In a word, they must be specified by some form of pattern recognition program rather than hard-wired.

Another area where pattern recognition helps the scientist is computer algebra. Closely related is the ability to translate mathematical formulae into machine code. So far we have stressed a FORTH programming style natural to that language, namely postfix notation, augmenting it primarily for readability or abstracting power. It cannot be denied, however, that sometimes it is useful simply to be able to write down a mathematical formula and have it translated automatically into executable form. This chapter develops the tools for symbolic programming and illustrates their use with a typical algebra program and a simple FORmula TRANslator.

\subsection{Rules}

Before we can specify rules we need a language to express them in. We need to be able to describe the grammar of the rules in some way. The standard notation states rules as regular expressions\footnote{See A.V. Aho, R. Sethi and J.D. Ullman, \textit{Compilers:...} (Addison-Wesley, Reading. 1988).}. The following rules describing some parts of FORTRAN illustrate how this works.

\begin{lstlisting}

\Rules for FORTRAN

\NOTATION:
\|              -> "or"
\^              -> "unlimited repetitions"
\^n             -> "0-n repetitions"
\Q              -> "empty set"
\&              -> + | -
\%              -> * | /
\<d>            -> "digit"

\NUMBERS:
\<int>          -> {-|Q} {<d> <d> ^8}
\<exp't>        -> {dDeE} {&|Q}{<d> <d> ^2} | Q
\<lp#>          -> {-|Q}{ <d> | Q} . <d> ^ <exp't>

\FORMULAS:
\<assign>       -> <subj> = <expression>
\<id>           -> <letter> {<letter>|<d>}^6
\<subject>      -> <id> {<idlist> | Q}
\<idlist>       -> ( <id> {, <id> } ^)
\<arglist>      -> ( <expr'n> {, <expr'n>}^)
\<func>         -> <id> <arglist>
\<expr'n>       -> <terrn> | <terrn> & <expr'n>
\<terrn>        -> <fctr> | <fctr> % <trm> | <fctr>**<fctr>
\<factor>       -> <id> | <tp#> |(<expr'n> )| (tum)

\end{lstlisting}

We use angular brackets " < ", " > " to set off "parts of speech" being defined, and arrows "->" to denote "is defined by". Other notational conventions, such as "|" to stand for "or", are listed in the "NOTATION" section of the rules list, mainly for mnemonic reasons. A statement such as

\begin{lstlisting}
\<int>      -> {-|Q}<d><d>^8
\end{lstlisting}

therefore means "an integer is defined by an optional leading minus sign, followed by 1 digit which is in turn followed by as many as 8 more digits". Similarly, the phrase

\begin{lstlisting}
\<assign>   -> <subj> = <expression>
\end{lstlisting}

means “an assignment statement consists of a subject ---a symbol that can be translated into an address in memory--- followed by an equals sign, followed by an expression". Literal symbols --- parentheses, decimal points, commas --- are shown in \textbf{bold} type.

Note that some of these definitions are recursive. A statement such as

\begin{lstlisting}
\<expr'n>   -> <term> | <term> & <expr'n>
\end{lstlisting}

seems to be defined in terms of itself. So it is a good bet the program that recognizes and translates a FORTRAN expression will be recursive, even if not explicitly so.

\subsection{Tools}

In order to apply a rule stated as a regular expression, we need to be able to recognize a given pattern. That is, given a string, we need —say— to be able to state whether it is a floating point number or something else. We want to step through the string, one character at a time, following the rule

\begin{lstlisting}
\<fp#>      -> {-|Q}{{d . | .d | d} d ^ exp't
\end{lstlisting}

This pattern begins with a minus or nothing, followed by a digit and a decimal point or a decimal point and a digit or a digit with no decimal point, followed by zero or more digits, then an exponent.

\subsubsection{Pattern recognizers}

One often sees pattern recognizers expressed as complex logic trees, \textit{i.e.} as sequences of nested conditionals, as in Fig. 11-1 on page 263 below. As we see, the tree is already five levels deep, even though we have concealed the decisions pertaining to the exponent part of the number in a word \textbf{exponent?}. When programmed in the standard procedural fashion with textbf{IF...ELSE...THEN} statements, the program becomes too long

\begin{figure}
    \caption{Fig. 11-1 \textit{Logic tree for <floating point \#>}}
\end{figure}

and too complex either for easy comprehension or for easy maintainance\footnote{These defects of nested conditionals are generally recognized. Commercially available CASE tools such as Stirling Castle’s \textit{Logic Gem} (that translates logical rules to conditionals); and Matrix Software's \textit{Matrix Layout} and AYECO, Inc.'s \textit{COMPEDITOR} (that translate tabular representations of PSMs to conditionals in any of several languages) were originally developed as in house aids.}

It has been known for many years that a better way to apply general rules — \textit{e.g.}, to detemiine whether a given string conforms to the rules for "floating point number" --- uses finite state machines (FSMs —we define them in §2 “2 below). Here is an example, written in standard FORTH:

\begin{lstlisting}
\ determine whether the string at Sadr is a fp#
:skip-   ( adr -- adr') DUP C@ ASCII- = - ;
:skip_dp ( adr -- adr') DUP C@ ASCII. = - ;
\ NOTE: these "hacks" assume "true" = -1.
:digit?  ( char -- f) ASCII 9 ASCII 0 WITHIN ;
: skip_dig ( adr2 adr1 -- adr2 adr1')
    BEGIN   DDUP > OVER C@ digit? AND
    WHILE     1+  REPEAT ;   \... cont'd below
:dDeE?   ( char -- f) 95 AND \->uppercase
    DUP ASCII D = SWAP ASCII E = OR ;

: skip_exponent ; \ this definition shown below
:fp#?    ( $adr -- f )
    DUP 0 OVER COUNT + C! \ add terminator
    DUP C@ 1+ OVER C!     \ count =count+1
    COUNT OVER + 1- SWAP  ( -- $end $beg )
    skip- skip_dig skip_dp skip_dig
    skip_exponent
    UNDER =          \$beg' = $end?
    SWAP C@ 0= AND ; \char[$beg']=terminal?

The program works like this:
\begin{itemize}
    \item Append a unique terminal character to the string.
    \item If the first character is "-" advance the pointer 1 byte, otherwise advance 0 bytes.
    \item Skip over any digits until a non-digit is found.
    \item If that character is a decimal point skip over it.
    \item Skip any digits following the decimal point.
    \item A floating point number terminates with an exponent formed according to the appropriate rule (p. 261). skip_exponent advances the pointer through this (sub)string, or else halts at the first character that fails to fit the rule.
    \item Does the initial pointer ($beg') now point to the calculated end of the string ($end)? And is the last character ( char[$beg'] ) the unique terminal? If so, report "true", else report "false".
\end{itemize}

We deferred the definition of skip_exponent. Using conditionals it could look like

\begin{lstlisting}
: skip_exponent ( adr -- adr' )
    DUP C@ dDeE? IF 1+ ELSE EXIT THEN
    skip- skip+
    DUP C@ digit? IF 1+ ELSE EXIT THEN
    DUP C@ digit? IF 1+ ELSE EXIT THEN
    DUP C@ digit? IF 1+ ELSE EXIT THEN ;
\end{lstlisting}

which,as we see in Fig. 11-2 below, has nearly as convoluted a logic tree as Fig. 11-1 on page 263 above.

\subsubsection{Finite state machines}

Just as we needed a FSM to achieve a graceful definition of fp\#?, we might try to define skip\_exponent as a state machine also. This means it is time to define what we mean by finite state machines. (We restrict attention to deterministic FSMs.) A finite state macliine\footnote{R. Sedgewick, Algorithms (Addison-Wesley Publishing Co., Reading MA 1983) p.257ff.}\footnote{A.V. Aho, R. Sethi and JD. Ullman, \textit{Compilers: Principles, TooLr and Techniques} (Addison Wesley Publishing Company, Reading, MA, 1988).} is a program (originally it was a hard-wired switching circuit\footnote{Zvi Kohavi, \textit{Switching and Finite Automata Theory}, 2nd ed. (McGraw-Hill Publishing Co., New York, 1978).}) that takes a set of discrete, mutually exclusive

\begin{figure}
    \caption{ Fig. 11-2 \textit{Logic tree for <exponent>}}
\end{figure}

inputs and also maintains a state variable that tracks the history of the machine's inputs. According to which state the machine is in, a given input will produce different results. The FSM program is most easily expressed in tabular form, as in Table 11-1, which we interpret as follows:

\begin{itemize}
    \item each major column heading is an input.
    \item the inputs must be mutually exclusive and exhaustive; to exhaust all possibilities we include "other".
    \item each row represents the current state of the machine.
    \item each cell contains an action, followed by a state-transition.
\end{itemize}

Table 11-1 Example of finite state machine arrow ( -> ) means 'next state'

Input:  other       dDeE        +/-         digit
State         ->          ->          ->          ->
0       Next  5     1+    1     Error 5     Next  5
1       Next  5     Next  5     1+ 2  1+    3
2       Next  5     Next  5     Next  5     1+    3
3       Next  5     Next  5     Next  5     1+    4
4       Next  5     Next  5     Next  5     1+    5

The tabular representation of a FSM is much clearer than the logic diagram, Fig. 11-2. Since the inputs must be mutually exclusive\footnote{"Mutually exclusive" means only one input at a time can be true.} and exhaustive\footnote{"Ehaustive" means every possible input must be represented.}, there are \textit{never} conditions that cannot be fulfilled —that is, leading to "dead" code— as frequently happens with logic trees (owing to human frailty). This means the chance of introducing bugs is reduced by FSMs in tabular form.

FORTRAN, BASIC or Assembler can implement FSMs with computed GOTOs. In BASIC, \textit{e.g.},

\begin{lstlisting}
    DEF SUB FSM (c$. adress)
    k% =0         ' convert input to column #
    C$=UCASE (c$)
    IF C$="D" OR C$="E" THEN k%=1
    IF C$="+" OR C$="-" THEN k%=2
    IF ASC(C$) > = 48 AND ASC(C$) < =57 THEN k%=3
    ' cont'd
\end{lstlisting}

\begin{lstlisting}
            ' begin FSM proper
    ON state% *3 + k% GOTO
       (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19)
    0: state%=5
    1: adress% = adress% +1 : state% = 1
    2: CALL Error: state% = 5                          'row 0
    3: state%=5
    4: state%=5
    5: state%=5
    6: adress% = adress% +1 : state% = 2                'row 1
    7: adress% = adress% +1 : state% = 3
       ...... etc. ......
    16:state%=5
    ...... etc.......                                   'row4
    19:adress% = adress% +1 : state% = 5
    END SUB
\end{lstlisting}

The advantage of FSM construction using computed GOTOs is simplicity; its disadvantage is the linear format of the program that hides the structure represented by the state table, 11-1. CASE statements —as in C, Pascal or QuickBASIC— are no clearer. We can use a state table for documentation, but the subroutine takes more-or-less the above form.

\subsubsection{FSMs In FORTH}

In the preceding FORTH example we synthesized the FSM from \textbf{BEGIN. ..WHILE. . .REPEAT} loops. FORTH’s lack of line-labels and GOTOs (jumps) imposed this method, producing code as untransparent as the BASIC version. The Eaker CASE statement can streamline the program,

\begin{lstlisting}
    CASE: ADVANCE? NEXT 1+ ;CASE
    : 1digit DUP C@ digit? ABS ADVANCE? ;
    : skip_exponent (adr -- adr')
        DUP C@ dDeE? IF 1+ ELSE EXIT THEN
        skip- skip+
        1digit 1digit 1digit ;
\end{lstlisting}

(three of four \textbf{IF...ELSE...THEN}s have been factored out and disguised as \textbf{CASE:}...\textbf{;CASE}), but this does not much improve clarity. We still need the state transition table to understand the program.

Various authors have tried to improve FSMs in FORTH using what amount to line-labels and GOTOs\footnote{J. Basile, \textit{J. FORTH Appl. and Res.} 1,2 (1982) 76-78.}\footnote{E. Rawson, \textit{J. FORTH Appl. and Res.} 3,4 (1986) 45-64.}\footnote{D.W. Berrian, \textit{Proc. 1989 Rochester FORTH Conf.} (Inst. for Applied FORTH Res., Inc., Rochester, NY 1989) p. 1-5.}. The resulting code is less elegant than the BASIC version shown above.

Whenever we reach a dead end, it is helpful to return to the
starting point, restate the problem and re-examine our basic
assumptions One fact our preceding false starts make abundantly
clear is that nowhere have we used the power of FORTH. Rather,
our attempts merely imitated traditional languages in FORTH.

But FORTH is an endlessly protean language that lends itself to
any programming style. Ideally FORTH relies on names so cun-
ningly chosen that programs become self-documenting-
readable at a glance.

Since state tables clearly document FSMs, it eventually occurred
to me to let FORTH compile the state table —representing an
FSM — directly to that FSM!

Compilation implies a compiling word; after some experimen-
tation1 I settled on the following usage

 

4 WIDE FSM: (exporters)

Input: | other | dDeE | +/- I did! i
state: ———————————————————————
(0) NEXT >5 1+ >1 Error >5 NEXT >5
(1) NEXT >5 NEXT >5 1+ >2 1+ >3
(2) NEXT >5 NEXT >5 NEXT >5 1+ >3
(3) NEXT >5 NEXT >5 NEXT >5 1+ >4
(4) NEXT >5 NEXT >5 NEXT >5 1+ >5 ;

\begin{figure}
    \caption{Fig. 11-3 \textit{Form of a FORTH finite state machine}}
\end{figure}





11. The

at process is described in detail in my article “Avoid Decisions”, Computers in

Physics 5,“ (1991) 386.
12. The FORTH word NEXT is the equivalent of N01’ in assembler.


The new defining word FSM: has a colon “ : " in its name
remind us of its function. Its children clearly must “know”
many columns they have. The word WIDE reminds us the new
created FSMs incorporate their own widths.

The column labels and table headers are merely comments fo
lowing “ \ ”; the state labels “ (0) ", “ (1 ) ", etc. arealso co
ments, delineated with parentheses. Their only purpose "
readability.

The actions \_ NEXT, Error, 1 + -in Fig. 11-3 are obvious: they;
are simply previously-defined words. But what about the state:
transitions “ > 1 ", “ > 2 ”, ? The easiest, most mnemonic and.1

natural way to handle state transitions defines them as CONSTANTs

 

O CONSTANT >0

1 CONSTANT >1

2 CONSTANT >2
etc.

which are also actions to be compiled into the FSM. This follows the:
general FORTH principle that words should execute themselves”..

11 Chapter S§2§§6 we used components of the compiler, par‘

ticularly the IMMEDIATE word ] (“switch to compile mode”),
to create self-acting jump tables. We apply the same method here:
The defining word FSM: will CREATE a new dictionary entry,
build in its width (number of columns) using “ , ”, and then
compile in the actions and state transitions as cfa’s of the ap-
propriate words.

The runtime code installed by DOES> provides a mechanism
for finding the addresses of action and state transition cor-1
responding to the appropriate input and current state (that is, in
the cell of interest). Then the runtime code updates the state.

 

13. That is, we should not continually reinvent interpreters equivalent to the FORTH interpreter. i

Form-1 Mil—WW 271

11) slow nesting of FSMs (Le., compiling one into another), we
incorporate the state variable for each child FSM within its data
structure. This technique, using one extra memory cell per FSM,
protects the state from accidental interactions, since if state has
no name it cannot be invoked inadvertamly.

The FORTH code that does all this is
\begin{lstlisting}
:WIDE O;
:FSM: widthon) CREATE ,,]
DOES> coI\#--)

UNDER D@    ( -- adr col\# width state)
* + 1+ 4'   ( -- adr offset )
OVER+       ( -- adr adr' )
DUP@ SWAP2+ ( -- adr [adr'] adr'+2 )
@EXECUTE    ( -- adr [adr'] state')

ROT I EXECUTE ;

O CONSTANT >0

1 CONSTANT >1

2 CONSTANT >2
.. etc.

\end{lstlisting}

We are now in a position to use the code for (exponent)
(defined in Fig. 11-3 on page 269 above) to define the key

word skip\_exponent appearing in fp\#?. The result 1s

\begin{lstlisting}

: skip exponent ( adr -- adr' )

' (exponent) OI \initialize state

BEGIN DUP C@ DUP (- - adr char)
dDeE? ABS OVER \input -> coI#
+/-? 2 AND + SWAP
digit? 3 AND + (--adrcol#)

' (exponent) @ \get state

5 < \ not done?

WHILE (exponent) REPEAT ;
\end{lstlisting}
554 Automatic converslon tables
Our preceding example used logic to compute (not decide!) the
conversion of input condition to a column number, via

( -- char) dDeE? ABS OVER

+/-? amp + SWAP
digit? amp + ( -- col\#)


When the input condition is a character, it is usually both faster
and clearer to translate to a column number using a lookup table
rather than tests and logic. That is, we can trade increased
memory usage for speed. If a program needs many different
pattern recognizers, it is worth generating their lookup tables via
a defining word rather than crafting each by hand.
\begin{lstlisting}
:TABLE: (- - #bytes)
CREATE HERE (- - #bytes tab[0] )
OVER ALLOT \ allot #bytes in dictionary
SWAP 0 FILL \ initialize to all 0's
DOES > + C@ ; ( n tab[0] - - [tab[n]])

: install (col# adr cham char.1 --) \ fast fill
SWAP 1 + SWAP
DO DDUP I+ Cl LOOP DDROP ;
\end{lstlisting}
Here is how we define a new lookup table:
\begin{lstlisting}
128 TABLE: [exp] \ define 128-byte table
\ modify certain chars
\ Note: all unmodified chars return col# 0

1 ASCII d ' [exp] + C! \col# 1
1 ASCII D '[exp] + Cl
1ASCII 9 '[exp] + Cl
1 ASCII E ' [exp] + Cl

2ASCII + '[exp] + Cl \col#2
2ASC|| - '[exp] + Cl

3 '[exp] ASC|l9 ASCIIO install \col#3
\end{lstlisting}
With the lookup table [exp], skip\_exponent becomes faster
and more graceful,

\begin{lstlisting}
: skip_exponent (adr - - adr')
' (exponent) OI \ state =0
BEGIN DUP C@ (- - adr char)
[exp] (- - adr col#)
' (exponent) @ (- - adr col# state)
5 < \ not done?
WHILE (exponent) REPEAT ;
\end{lstlisting}

at a cost of 128 bytes of dictionary space. If dictionary space
becomes tight, it would be perfeme simple to export the lookup

\end{document}