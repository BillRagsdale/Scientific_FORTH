MM?"

mi—rmeetumroam 1

Toward Scientiﬁc FORTH

Comm!

51 Overview of FORTRAN
§§1 Programs and sub-programs
§§2 Arithmetic statements
§§3 Function library

52 What is FORTH 7

m VQMM

This book presents extensions to the FORTH programming

language suitable for scientiﬁc and technical computation.
The aim is to retain FORTRAN’s good points while taking ad-
vantage of the simplicity, ﬂexibility, extensibility, and control
offered by FORTH.

The resulting dialect has many advantages over more traditonal
languages, both for small, casual, throw-away programs as well as
for large, complex projects. FORTH lends itself to many
programming styles, including procedural, object-oriented or
event-driven. Its speed and economical use of memory suit
FORTH for real-time, on-line data pre-processing as well as as
off-line analysis and computation.

Because FORTH is a threaded, interpretive languagel its struc-
ture and philosophy differ radically from those of traditional
languages like FORTRAN and BASIC. This introductory chapter

 

1. This dua'iption refers to FORTH'I compilation scheme. See, e.g., R.G. Loeliger, Threaded Inter-
pretive W (Byte Publications, Inc, Peterborough. NH, 1981). We shall have more to say
about 'n in mptu z

eWMth—Mmm.

2 Chapter 1 — Toward Sclentllc FORTH .9ch FORTH

explains some of the differences by contrasting F ORTRAN with
FORTH.

51 Overview of FORTRAN

FORTRAN is a compiled high level languagez. The program-

mer writes a source code program using FORTRAN’s gram-
matical rules, data structures and operators; a special computer
program (the compiler) then translates the source into a (re-
locatable) machine language version (object code). Another
machine language program (the linker) then links modules of
object code into an executable program that can be run under the
control of the operating system of the computer.

Compilation produces executable programs that run fast, without
the tedium of writing them directly in machine code (or assembly
language). The source code will run virtually the same on any
machine for which a compiler exists. That is, the source code is
portable. Among other things, portability . takes possible the
development of stande libraries of reusable code for perform—
ing standard tasks like solving linear equations or computing
Bessel functions.

The chief disadvantage of compilation is its tedium. Testing small
portions of a program in isolation is virtually impossible — either
an “exercise” program must be written and compiled with the
module being tested, or else the entire program must be compiled
as a unit. This process is so time-consuming it discourages ﬁne-
grained decomposition of programs into small, comprehensible
components.

§§1 Programs and sub-programs
FORTRAN program consists of a master, or main program
hat either stands alone or can call (transfer control to) sub-
programs. Sub-programs fall into two classes: subroutines and

 

2. Although some interpreted FORTRANs such as WATFOR have been developed.

MM”!

Murmur-mew 3

(auction. Both receive arguments (input) from the calling pro-
gram; they differ in how melts (output) are returned to the
calling program. Subroutines are called by the phrase

CALL SUB1(A,B,RESULT)

where A and B are arguments and RESULT is the result (which is
returned in the argument list). By contrast, a function is called by
having its name placed in an arithmetic expression. When the
expression is evaluated, the value of the function (at its given
arguments) is inserted in the expression where the function name
appeared. That is, we might have a phrase like

OPSIDE = HYPOT'SIN(3.14159*ANGLE/180.)

Here the argument of SIN is also an expression which must be
evaluated before being passed to the SIN subroutine. When SIN
is evaluated, its value is returned, multiplied by HYPOT and the
product stored in the area labelled OPSIDE.

There is no speciﬁc calling heirarchy in FORTRAN — a function
can call a subroutine or vice-versa and the called sub-program can
call still further sub-programs.

§§2 Arithmetic statements

F‘ORTRAN arithmetic is performed by “smart” operators ac-

ting on typed variables and literals. A variable is simply a
name that refers to a specific location in memory. The type
declaration is a way to let the compiler know how much memory
to allot for that variable. A literal is an explicit number that
appears in the program, such as the values 3.14159 and 180. in
the preceding example.

FORTRAN arithmetic expressions can freely mix types. To make
this possible, the arithmetic operators are overloaded in the sense
that the plus sign —say— can add ﬂoating point numbers, integers
or complex numbers in any combination, mixture or order.

Consider, e.g., the actions performed by the FORTRAN compiler
in parsing the arithmetic assignment statement

OJtlhnMNoﬂoim—Almm.

Chapter 1 - Toward Solomlﬂc FORTH Scientiﬁc FORTH

A =B1*3 +82’1.2E-5 - H(3)/3.1415926535897QD14+K

keeping 1n mind that 13n FORTRAN, data types can be declared
explicitly or implicitlys:

0 Define and reserve space for a ﬂoatin -point single precision
variable A (implicit type REAL) if has not been deﬁned
previously (perhaps as something else);

0 Convert the literal integer constant 3 to ﬂoating point and
multiply it by the (implicit- REAL) variable 81’ 5 current value
(fletchp) from memory), placing the product 1n temporary storage

0 Fetch (implicit-REAL) variable 82 and multiply it by the
REAL literal 1 .2E-5;

0 Add the second product to the contents of TEMP;
o Fetch the 3rd element of the (implicit-REAL) array H;

0 Divide by the DREAL (double-precision) literal
3.141592653589790“ (=7r), converting to and from DREAL
forrnatasnecessary,

0 Convert the dividend to REAL and subtract from TEMP;

0 Convert (implicit) INTEGER variable K to REAL and add to
TEMP;

0 Move the result from TEMP to the memory reserved for A

These actions can be over-ridden by explicit type declarations.
For example, if the program had contained the following state-
ments in its ﬁrst few lines:

INTEGERA, H(15) 131 132
REALK

the conversions and assignments would have been ﬂoating point
to integer, rather than vice-versa.

 

The original version of FORTRAN included naming conventions such that names beginning
with letters I, J, K, L, M and N are assumed to be integers, while those beginning with other let-
ters are assumed to be single-precision ﬂoating point numbers. Subsequent versions have main-
tained this convention for backward compatibility.

To achieve the simplicity of mixed-mode expressions, the

FORTRAN compiler must be prepared for any eventuality.
The operators “ +", “-", “a”, “I" and “ =" must be “smart”
(overloaded)— they must “know" (or at least be able to ﬁgure
out) what kinds of numbers are going to be used and what kinds
of arithmetic will be used to combine them. The FORTRAN
exponentiation operator “u" must similarly “know” whether the
base is INTEGER, REAL, DREAL or COMPLEX (some
FORTRAN’s even permit DCOMPLEX), and the same for the
exponent. That is, it must be able to compile 16 (or 25) versions
of to, depending on circumstances. The compiler must contain
decision branches to handle every eventuality. Compilers for
languages such as FORTRAN, PASCAL, C or Modula-Z are
therefore complex and slow.

Smart operators beneﬁt the user by simplifying source code. The
beneﬁt is only partial, however, since the programmer must still
keep track of types in calling sequences for subroutines, and in
declaring global variables with COMMON and EQUIV-
ALENCE statements.

Since FORTRAN subroutines can be compiled separately, many
a subtle bug has been introduced by omitting an argument from
a long calling sequence, or by inverting arguments in a list (there-
by, for example, telling a subroutine to interpret a REAL as a very
large INTEGER). I can vouch for these problems from long, sad
experience debugging FORTRAN.

FORTRAN provides a limited suite of data types: INTEGER,
LONG-INTEGER, REAL, DREAL, COMPLEX, DCOM-
PLEX, IDGICAL and CHARACTER. It provides no facilities
for deﬁning any new types (other than arrays of the above). Arrays
must be declared according to a strict format - up to 3 indices
are permitted.

FORTRAN's array notation is simple, logical and follows the
conventions of algebra: parentheses replace subscripts via

A“ o A(I,J).

OJUMVNOHOinMmm.

Chapter 1 — Toward ScIentIfIc FORTH Scientiﬁc FORTH

ORTRAN provides facilities for initializing constants and

variables at run-time: the DATA statement within a program
or subroutine, and the BLOCK DATA subprogram for initializ-
ing global variables in COMMON.

Limited control of memory allocation is provided: placed at the
beginning of a program or subprogram, COMMON, BLOCK
COMMON and EQUIVALENCE speciﬁcation statements allow
local variables to be made global or partially global, under the
same or different names. DIMENSION allocates memory for
arrays. (Dynamic re-allocation is not permitted.)

Finally, EXTERNAL directs the compiler (more precisely, the
linker and loader) to search outside the subprogram for the
specified name: for example, the usage

SUBROUTINE MYSUB(X,DUMMY,ANSWER)

permits the name of a function or subroutine to be inserted as an
argument into the calling string at runtime. This facility is essen-
tial to separately compiled modules, of course.

Modern FORTRAN has evolved by accretion, with additions

designed not to obsolesce older methods of accomplishing
tasks. Thus FORTRAN has several ways to define functions,
through external subprograms and through inline deﬁnitions; and
several ways to allocate memory for arrays. Data types can be
changed explicitly via functions and implicitly via replacement
statements, leading to such redundancies as

A = FLOAT(K)

01’

K = |FIX(A)

§§3 Function library
Crucial to FORTRAN’s utility in scientific programming is the
mathematical function library, including REAL, DREAL and
COMPLEX (at least!) versions of trigonometric functions, ex-
ponentials, logarithms, inverse trigonometric functions, some-

Mt—rmmm 7

times hyperbolic functions and their inverses, and often a raMorn
number generator of uncertain quality.

FORTRAN supports modularity through separate compilation of
functions and subroutines. For example, we can write a library
function to compute complex Legendre polynomials:

COMPLEX FUNCTION CPLEG(Z,N)
COMPLEX Z,CPO, CP1, CMPLX
CPLEG = CMPLX(1.,O.)

IF (N no.0) serum

CPO = CMPLX(0., o.)

K=0
1CP1=CPLEG
K1=K+1

CPLEG =((K+K1)*Z*CP1- K'CPO)/K1
IF (K.EQ.N) RETURN

CPO = CP1
GOTO 1
END

Because all the decisions as to which overloaded operator to use
must be made when the function is compiled, a single-precision
REAL Legendre polynomial routine will require a separate ver-
sion from the above.

Worse, because the typical function or subroutine calling se-
quence wastes memory and execution time, there are severe
penalties in efficiency that militate against f'me-grained decom-
position. That is, the code in one routine is unlikely to be re-used
in another routine. Instead, it must be repeated, wasting memory.

Chapter 1 - Toward Sclentlﬂc FORTH Scientiﬁc FORTH

52 What Is FORTH ?

When I first encountered FORTH, it appeared to me as Look-

ing Glass Land must have, to Alice. Twenty-ﬁve years' ex-
perience with FORTRAN colored my perceptions, making
FORTH seem very strange indeed.

FORTH makes no essential distinctions between data structures,
operators, functions or subroutines. Everything in FORTH is the
same thing: a word. In appearance, words are strings of text
separated by spaces. Functionally, words are subroutines. To
execute a word, type its name, then a carriage return. No
GOSUBs, CALLS or RETURNS are needed. This simple gram-
mar is beautiful because it leaves nothing to remember.

Whereas FORTRAN imposes stringent naming conventions —
names must begin with a letter, may be no longer than seven
characters, and may use only letters and digits — FORTH has no
such restrictions. FORTH names can be much more expressive
than those in FORTRAN or even Pascal and C, for that matter.

For a preview of FORTH’s ﬂavor, consider the FORTH version
of the Legendre polynomial function :

\ Gx are generic operations (Real or Complex)
:S->FS S->F REAL*8 F>FS;

:PLEG ([z]n--::--p[z,n])
>R DUP>R >FS (-- ::-- 2)
R@ G=1Fl> G=OFl>(--n :: --z P1 P0)
?DUP IF \Ioopntimes,ifn >0
0 DO \begin loop
| S->FS G* (2: --2 P1 P0*I)

FS>F GOVER GOVER
G* |2* 1+ S->FS

G* F > FS G-
I1+ S->FS G/ (::--2 P1 P2)
GSWAP (::--z P2 P1)
LOOP \ and loop
THEN \end IF. . . THEN clause
GDROP GPLUCK ; \ clean up stacks

 

The items between parentheses, ( ), and following a backslash, “\”, are comments.

macaw

Ml—TWMFWH 9

We note the following similarities and differences between the
FORTRAN and FORTH versions:

0 Th are of similar length. The FORTH version contains more

exp icit steps. and looks more tic. The FORTRAN version
looks more like algebraic formu ae.

e The FORTH function lacks an argument list. Fun ions and
subroutines generally look for arguments on stacks built into
the system.

c The code uses both primitive words from the FORTH “ker-
nel", as well as advanced concepts from Scientific FORTH. In
particular, the FORTH version employs generic o erations
with “run-time bindin ", so one versron works with EAL’4,
REAL‘8, COMPLE ‘8 and COMPLEX‘16 data types. By
contrast, in FORTRAN one needs a separate Legendre func—
tion for each type desired.

postﬁx (“reverse Polis ’ notation, just like a Hewlett—Packard
calculator. Thus, while ORTRAN lets us display the algo-
rithm in almost-algebraic form, FORTH’s pgstﬁx arithmetic
conceals the algorithm b decomposing it. is disadvantage
can be overcome by suita 1e commenting, through telegraphic
choices of names, or by employing the FORmula TRANslator
from Chapter 11.

e FORTH looks more cryptic than FORTRAN because it uses
h

FORTH ’5 simple linguistic structure permits almost self-com-

menting code , through clever naming of data structures and
operations. In Chapter 2 we shall comment in detail on this and
other differences between FORTRAN and FORTH.

Every operation that FORTRAN is capable of can be pro-
grammed easily in FORTH. For example, the EXTERNAL spec-
iﬁcation of FORTRAN has its analogue in “vectoring”.

 

5. A stack is a data structure like a pile of cards. each containing a number. New numbers are
added by plating them atop the pile, numbers are also deleted from the top. In essence, a stack
is a “last-in, ﬁrst-out” buﬂer.

6. L. Brodie, WFarth (Prentice-Hall, Inc. Englewood Cliffs, New Jersey, 1%). M. Hans,
“Structured Programming", Dr. Dobb‘s Jamal. July 1%6.

OWVNoﬂelm-Mmm.

10

Chapter 1 — Toward Sclentllle FORTH Scientiﬁc FORTH

But FORTH can not only imitate FORTRAN —using far less
memory, compiling and debugging much faster, and often execut-
ing faster as well— it can perform tricks that FORTRAN ac-
complishes barely or not at all. The programming examples
sprinkled throughout the book, and concentrated in Chapters 6,
8 and 11 offer repeated concrete proof for these assertions.

My experience with FORTH following 25 or so years in which
FORTRAN (and sometimes BASIC) were my staple languages
leads me to believe the chief advantage of FORTH over the more
common procedural languages is its potential for directness and
clarity of algorithmic expression.

One reason FORTH has not yet realized its potential in scien-

tific computing may be that scientists and programmers tend
to reside in orthogonal communities, so that no one has until now
troubled to publicize the extensions that make FORTH con-
venient for scientiﬁc problem-solving. My sincere hope is that this
book will in some measure mitigate this lack.

